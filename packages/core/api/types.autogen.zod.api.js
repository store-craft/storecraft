// Generated by ts-to-zod
import { z } from "zod";

export const cORSOptionsSchema = z.object({
  origin: z.union([z.string(), z.array(z.string())]),
  allowMethods: z.array(z.string()).optional(),
  allowHeaders: z.array(z.string()).optional(),
  exposeHeaders: z.array(z.string()).optional(),
  maxAge: z.number().optional(),
  credentials: z.boolean().optional(),
});

export const errorItemSchema = z.object({
  message: z.string().optional(),
  code: z.string().optional(),
  expected: z.string().optional(),
  received: z.string().optional(),
  path: z.array(z.string()).optional(),
});

export const errorSchema = z.object({
  messages: z.array(errorItemSchema).optional(),
});

export const handleSchema = z.string();

export const idSchema = z.string();

export const timestampsSchema = z.object({
  created_at: z.string().optional().describe("ISO string creation time"),
  updated_at: z.string().optional().describe("ISO string update time"),
});

export const searchableSchema = z.object({
  search: z.array(z.string()).optional(),
});

export const withOptionalIDSchema = z.object({
  id: z.string().optional().describe("ID"),
});

export const idableConcreteSchema = z.object({
  id: z.string().describe("ID"),
});

export const withOptionalHandleOrIDSchema = z.object({
  id: z.string().optional().describe("Optional `id`"),
  handle: z.string().optional().describe("Optional `handle`"),
});

export const attributeTypeSchema = z.object({
  key: z.string().describe("The key"),
  value: z.string().optional().describe("The value"),
});

const jWTClaimsSchema = z.object({
  iss: z.string(),
  sub: z.string(),
  aud: z.string(),
  exp: z.number(),
  nbf: z.number(),
  iat: z.number(),
  jti: z.string(),
  roles: z.array(z.string()).describe("User roles and authorizations"),
});

export const authBaseTypeSchema = z.object({
  email: z.string().email().describe("Email of user"),
  password: z.string().min(4).max(20).describe("password"),
});

export const roleSchema = z
  .union([z.literal("admin"), z.literal("user"), z.string()])
  .describe("Role of authenticated user");

export const apiAuthSigninTypeSchema =
  authBaseTypeSchema.describe("Sign in interface");

export const apiAuthSignupTypeSchema = authBaseTypeSchema.extend({
  firstname: z
    .string()
    .optional()
    .describe("(optional) readable `name` of `customer`"),
  lastname: z
    .string()
    .optional()
    .describe("(optional) readable `name` of `customer`"),
});

export const apiAuthChangePasswordTypeSchema = z.object({
  user_id_or_email: z.string().describe("User `ID` or `Email`"),
  current_password: z.string().describe("Current password"),
  new_password: z.string().describe("New password"),
  confirm_new_password: z
    .string()
    .describe("Again New password for confirmation"),
});

export const apiAuthRefreshTypeSchema = z.object({
  refresh_token: z.string().describe("A refresh token"),
});

export const apiTokenWithClaimsSchema = z.object({
  token: z.string().describe("a token (`access` or `refresh`)"),
  claims: jWTClaimsSchema
    .partial()
    .describe("Claims the `JSON Web Token` holds"),
});

export const apiKeyResultSchema = z.object({
  apikey: z
    .string()
    .describe(
      "The `apikey` is `base64_uri(apikey@storecraft.api:{password})`.\nIt will be shown only once to the user, at the `backend`, the password hash\nwill be saved, thus, the real password is only known to the user.",
    ),
});

export const apiAuthResultSchema = z.object({
  token_type: z
    .string()
    .describe("The interface of token, should be `bearer` or `refresh`"),
  user_id: z.string().describe("the `ID` of user, example `au_....`"),
  access_token: apiTokenWithClaimsSchema.describe("The access token"),
  refresh_token: apiTokenWithClaimsSchema.describe("The refresh token"),
});

export const baseTypeSchema = idableConcreteSchema
  .extend(timestampsSchema.shape)
  .extend({
    media: z.array(z.string()).optional().describe("List of images urls"),
    attributes: z
      .array(attributeTypeSchema)
      .optional()
      .describe("List of attributes"),
    tags: z
      .array(z.string())
      .optional()
      .describe("List of tags , example ['genere_action', 'rated_M', ...]"),
    description: z.string().optional().describe("Rich description"),
    active: z.boolean().optional().describe("Is the entity active ?"),
  });

export const tagTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("The key name"),
  values: z.array(z.string()).describe("List of values, related to the key"),
});

export const tagTypeUpsertSchema = tagTypeSchema
  .omit({ id: true, handle: true })
  .extend(withOptionalHandleOrIDSchema.shape);

export const collectionTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("The `handle` of the entity"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of collection"),
  active: z.boolean().describe("Is the entity active ?"),
  published: z
    .string()
    .optional()
    .describe(
      "Collections can be exported into\njson with products, this is the url",
    ),
});

export const collectionTypeUpsertSchema = collectionTypeSchema
  .omit({ id: true, handle: true })
  .extend(withOptionalHandleOrIDSchema.shape);

export const variantOptionSelectionSchema = z.object({
  option_id: z.string().describe("Variant option id"),
  value_id: z.string().describe("Variant selected value id"),
});

export const textEntitySchema = z.object({
  id: z.string().describe("The `id` of the entity"),
  value: z.string().describe("The text value of the entity"),
});

export const handleAndIDSchema = z.object({
  id: z.string().describe("The `id` of the entity"),
  handle: z.string().describe("The `handle` of the entity"),
});

export const variantOptionSchema = z.object({
  name: z
    .string()
    .min(3, "Name should be longer than 3")
    .describe("Variant option name (for example 'Size')"),
  id: z.string().describe("Variant option id"),
  values: z
    .array(textEntitySchema)
    .describe(
      "Variant option values\n(for example `Small` / `Medium` / `Large` ..)",
    ),
});

export const discountApplicationEnumSchema = z.object({
  Auto: z.object({
    id: z.literal(0),
    name: z.string().optional(),
    name2: z.literal("automatic"),
  }),
  Manual: z.object({
    id: z.literal(1),
    name: z.string().optional(),
    name2: z.literal("manual"),
  }),
});

export const filterValuePInCollectionsSchema = z
  .array(
    z.object({
      id: z
        .string()
        .optional()
        .describe("`p_in_collections` filter, `id` of collection"),
      title: z
        .string()
        .optional()
        .describe("`p_in_collections` filter, `title` of collection"),
      handle: z
        .string()
        .optional()
        .describe("`p_in_collections` filter, `handle` of the collection"),
    }),
  )
  .describe("Filter for product in collections");

export const filterValuePNotInCollectionsSchema =
  filterValuePInCollectionsSchema.describe(
    "Filter for product not in collections",
  );

export const filterValuePInProductsSchema = z
  .array(
    z.object({
      id: z
        .string()
        .optional()
        .describe("`p_in_products` filter, `id` of `product`"),
      title: z
        .string()
        .optional()
        .describe("`p_in_products` filter, `title` of `product`"),
      handle: z
        .string()
        .optional()
        .describe("`p_in_products` filter, `handle` of the `product`"),
    }),
  )
  .describe("Filter for product discount, product in handles");

export const filterValuePNotInProductsSchema =
  filterValuePInProductsSchema.describe(
    "Filter for product discount, product not in handles",
  );

export const filterValuePInTagsSchema = z
  .array(z.string())
  .describe("Filter for product discount, product has tags");

export const filterValuePNotInTagsSchema = z
  .array(z.string())
  .describe("Filter for product discount, NOT has tags");

export const filterValuePAllSchema = z
  .object({})
  .describe("Filter for product discount,\nthat chooses all products");

export const filterValuePInPriceRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`p_in_price_range` filter From price"),
    to: z.number().describe("`p_in_price_range` filter To price"),
  })
  .describe("Filter for product discount, product in price range");

export const filterValueOSubtotalInRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`o_subtotal_in_range` filter From price"),
    to: z.number().optional().describe("`o_subtotal_in_range` filter To price"),
  })
  .describe("Filter for order discount, subtotal in range");

export const filterValueOItemsCountInRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`o_items_count_in_range` filter From count"),
    to: z
      .number()
      .optional()
      .describe("`o_items_count_in_range` filter To count"),
  })
  .describe("Filter for order discount, items count in range");

export const filterValueODateInRangeSchema = z
  .object({
    from: z
      .string()
      .optional()
      .describe("`o_date_in_range` filter From date `ISO` format"),
    to: z
      .string()
      .optional()
      .describe("`o_date_in_range` filter To date `ISO` format"),
  })
  .describe("Filter for order discount, subtotal in range");

export const filterValueOHasCustomersSchema = z
  .array(
    z.object({
      id: z.string().describe("`id` of `customer`"),
      email: z.string().optional().describe("(optional) `email` of `customer`"),
      firstname: z
        .string()
        .optional()
        .describe("(optional) readable `name` of `customer`"),
      lastname: z
        .string()
        .optional()
        .describe("(optional) readable `name` of `customer`"),
    }),
  )
  .describe("Filter for order discount, order has customer id");

export const filterMetaEnumSchema = z.object({
  any: z.object({
    id: z.number().optional(),
    interface: z.string().optional(),
    op: z.string().optional(),
    name: z.string().optional(),
  }),
  p_in_collections: z.object({
    id: z.literal(0),
    type: z.literal("product"),
    op: z.literal("p-in-collections"),
    name: z.string().optional(),
  }),
  p_not_in_collections: z.object({
    id: z.literal(1),
    type: z.literal("product"),
    op: z.literal("p-not-in-collections"),
    name: z.string().optional(),
  }),
  p_in_products: z.object({
    id: z.literal(2),
    type: z.literal("product"),
    op: z.literal("p-in-products"),
    name: z.string().optional(),
  }),
  p_not_in_products: z.object({
    id: z.literal(3),
    type: z.literal("product"),
    op: z.literal("p-not-in-products"),
    name: z.string().optional(),
  }),
  p_in_tags: z.object({
    id: z.literal(4),
    type: z.literal("product"),
    op: z.literal("p-in-tags"),
    name: z.string().optional(),
  }),
  p_not_in_tags: z.object({
    id: z.literal(5),
    type: z.literal("product"),
    op: z.literal("p-not-in-tags"),
    name: z.string().optional(),
  }),
  p_all: z.object({
    id: z.literal(6),
    type: z.literal("product"),
    op: z.literal("p-all"),
    name: z.string().optional(),
  }),
  p_in_price_range: z.object({
    id: z.literal(7),
    type: z.literal("product"),
    op: z.literal("p-in-price-range"),
    name: z.string().optional(),
  }),
  o_subtotal_in_range: z.object({
    id: z.literal(100),
    type: z.literal("order"),
    op: z.literal("o-subtotal-in-range"),
    name: z.string().optional(),
  }),
  o_items_count_in_range: z.object({
    id: z.literal(101),
    type: z.literal("order"),
    op: z.literal("o-items-count-in-range"),
    name: z.string().optional(),
  }),
  o_date_in_range: z.object({
    id: z.literal(102),
    type: z.literal("order"),
    op: z.literal("o-date-in-range"),
    name: z.string().optional(),
  }),
  o_has_customer: z.object({
    id: z.literal(103),
    type: z.literal("order"),
    op: z.literal("o-has-customer"),
    name: z.string().optional(),
  }),
});

export const discountMetaEnumSchema = z.object({
  regular: z.object({
    id: z.literal(0),
    type: z.literal("regular"),
    name: z.string().optional(),
  }),
  bulk: z.object({
    id: z.literal(1),
    type: z.literal("bulk"),
    name: z.string().optional(),
  }),
  buy_x_get_y: z.object({
    id: z.literal(2),
    type: z.literal("buy_x_get_y"),
    name: z.string().optional(),
  }),
  order: z.object({
    id: z.literal(3),
    type: z.literal("order"),
    name: z.string().optional(),
  }),
  bundle: z.object({
    id: z.literal(4),
    type: z.literal("bundle"),
    name: z.string().optional(),
  }),
  any: z.object({
    id: z.number().optional(),
    type: z.never().optional(),
    name: z.string().optional(),
  }),
});

export const regularDiscountExtraSchema = z.object({
  fixed: z
    .number()
    .describe("`RegularDiscountExtra` params, Fixed price addition"),
  percent: z.number().describe("`RegularDiscountExtra` params, Percents off"),
});

export const orderDiscountExtraSchema = z.object({
  fixed: z
    .number()
    .describe("`OrderDiscountExtra` params, Fixed price addition"),
  percent: z.number().describe("`OrderDiscountExtra` params, Percents off"),
  free_shipping: z
    .boolean()
    .optional()
    .describe("`OrderDiscountExtra` params, Do we have free shipping ?"),
});

export const bulkDiscountExtraSchema = z.object({
  fixed: z
    .number()
    .describe("`BulkDiscountExtra` params, Fixed price addition"),
  percent: z.number().describe("`BulkDiscountExtra` params, Percents off"),
  qty: z
    .number()
    .describe(
      "`BulkDiscountExtra` params, The integer quantity\nfor which the discount is given",
    ),
  recursive: z
    .boolean()
    .optional()
    .describe(
      "`BulkDiscountExtra` params, Apply the discount as\nmany times as possible",
    ),
});

export const bundleDiscountExtraSchema = z.object({
  fixed: z
    .number()
    .describe("`BundleDiscountExtra` params, Fixed price addition"),
  percent: z.number().describe("`BundleDiscountExtra` params, Percents off"),
  recursive: z
    .boolean()
    .optional()
    .describe(
      "`BundleDiscountExtra` params, Apply the discount\nas many times as possible",
    ),
});

export const filterSchema = z.object({
  meta: z
    .union([
      filterMetaEnumSchema.shape.p_all,
      filterMetaEnumSchema.shape.p_in_collections,
      filterMetaEnumSchema.shape.p_not_in_collections,
      filterMetaEnumSchema.shape.p_in_tags,
      filterMetaEnumSchema.shape.p_not_in_tags,
      filterMetaEnumSchema.shape.p_in_products,
      filterMetaEnumSchema.shape.p_not_in_products,
      filterMetaEnumSchema.shape.p_in_price_range,
      filterMetaEnumSchema.shape.o_date_in_range,
      filterMetaEnumSchema.shape.o_has_customer,
      filterMetaEnumSchema.shape.o_items_count_in_range,
      filterMetaEnumSchema.shape.o_subtotal_in_range,
    ])
    .describe("Meta data related to identifying the filter"),
  value: z
    .union([
      filterValuePInCollectionsSchema,
      filterValuePNotInCollectionsSchema,
      filterValuePInProductsSchema,
      filterValuePNotInProductsSchema,
      filterValuePInTagsSchema,
      filterValuePNotInTagsSchema,
      filterValuePInPriceRangeSchema,
      filterValueOSubtotalInRangeSchema,
      filterValueOItemsCountInRangeSchema,
      filterValueODateInRangeSchema,
      filterValueOHasCustomersSchema,
    ])
    .optional()
    .describe("The filter params"),
});

export const shippingMethodTypeSchema = baseTypeSchema.extend({
  price: z
    .number()
    .min(0, "Please set a price > 0")
    .describe("Shipping method price"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Name of shipping method"),
  handle: z.string().describe("Readable `handle` of shipping"),
});

export const postTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("Unique `handle`"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of post"),
  text: z.string().describe("Rich text of post"),
});

export const addressTypeSchema = z.object({
  firstname: z.string().optional().describe("First name of recipient"),
  lastname: z.string().optional().describe("Last name of recipient"),
  phone_number: z
    .string()
    .regex(/^([+]?d{1,2}[-s]?|)d{3}[-s]?d{3}[-s]?d{4}$ Invalid phone number/)
    .optional()
    .describe("The phone number of the recipient"),
  company: z.string().optional().describe("Optional company name of recipient"),
  street1: z.string().optional().describe("Street address 1"),
  street2: z.string().optional().describe("Street address 2"),
  city: z.string().optional().describe("City"),
  country: z.string().optional().describe("Country"),
  state: z.string().optional().describe("State"),
  zip_code: z.string().optional().describe("ZIP code"),
  postal_code: z.string().optional().describe("Postal code"),
});

export const customerTypeSchema = baseTypeSchema.extend({
  auth_id: z
    .string()
    .optional()
    .describe(
      "The `auth id` of the customer. it is the same as\ncustomer `id` with `au` prefix instead",
    ),
  firstname: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .optional()
    .describe("Firstname"),
  lastname: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .optional()
    .describe("Lastname"),
  email: z.string().email().describe("Email of customer"),
  phone_number: z
    .string()
    .regex(/^([+]?d{1,2}[-s]?|)d{3}[-s]?d{3}[-s]?d{4}$/)
    .optional()
    .describe("The phone number"),
  address: addressTypeSchema.optional().describe("Address info of customer"),
});

export const customerTypeUpsertSchema = customerTypeSchema
  .omit({ id: true })
  .extend(withOptionalIDSchema.shape);

export const imageTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("Unique handle"),
  name: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("Name"),
  url: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("It's published public url"),
  usage: z
    .array(z.string())
    .optional()
    .describe("List of assets using this image"),
});

export const imageTypeUpsertSchema = imageTypeSchema
  .omit({ id: true, handle: true })
  .extend(withOptionalHandleOrIDSchema.shape);

export const shippingMethodTypeUpsertSchema = shippingMethodTypeSchema
  .omit({ id: true, handle: true })
  .extend(withOptionalHandleOrIDSchema.shape);

export const postTypeUpsertSchema = postTypeSchema
  .omit({ id: true, handle: true })
  .extend(withOptionalHandleOrIDSchema.shape);

export const settingsTypeSchema = baseTypeSchema;

export const notificationActionTypeSchema = z
  .union([z.literal("route"), z.literal("url")])
  .describe(
    "'route' means routing inside admin panel 'url' is linking to a url",
  );

export const notificationActionRouteParamsSchema = z.object({
  collection: z.string().describe("Which collection"),
  document: z.string().describe("Which document"),
});

export const notificationActionUrlParamsSchema = z.object({
  new_window: z.boolean().optional().describe("Ppen the url in new window"),
  url: z.string().describe("The url to open"),
});

export const orderContactSchema = z.object({
  firstname: z.string().optional().describe("First name"),
  lastname: z.string().optional().describe("Last name"),
  phone_number: z.string().optional().describe("Phone number"),
  email: z.string().optional().describe("Email"),
  customer_id: z.string().optional().describe("Customer `id`"),
});

export const validationEntrySchema = z.object({
  id: z.string().describe("`id`"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .optional()
    .describe("title"),
  message: z
    .union([
      z.literal("shipping-method-not-found"),
      z.literal("product-not-exists"),
      z.literal("product-out-of-stock"),
      z.literal("product-not-enough-stock"),
      z.literal("product-inactive"),
    ])
    .optional()
    .describe("message"),
});

export const checkoutStatusEnumSchema = z.object({
  created: z.object({
    id: z.literal(0),
    name2: z.literal("created"),
    name: z.string().optional(),
  }),
  requires_action: z.object({
    id: z.literal(1),
    name2: z.literal("requires_action"),
    name: z.string().optional(),
  }),
  failed: z.object({
    id: z.literal(2),
    name2: z.literal("failed"),
    name: z.string().optional(),
  }),
  complete: z.object({
    id: z.literal(3),
    name2: z.literal("complete"),
    name: z.string().optional(),
  }),
  unknown: z.object({
    id: z.literal(4),
    name2: z.literal("unknown"),
    name: z.string().optional(),
  }),
});

export const paymentOptionsEnumSchema = z.object({
  unpaid: z.object({
    id: z.literal(0),
    name: z.string().optional(),
    name2: z.literal("unpaid"),
  }),
  authorized: z.object({
    id: z.literal(1),
    name: z.string().optional(),
    name2: z.literal("authorized"),
  }),
  captured: z.object({
    id: z.literal(2),
    name: z.string().optional(),
    name2: z.literal("captured"),
  }),
  requires_auth: z.object({
    id: z.literal(3),
    name: z.string().optional(),
    name2: z.literal("requires_auth"),
  }),
  voided: z.object({
    id: z.literal(4),
    name: z.string().optional(),
    name2: z.literal("voided"),
  }),
  failed: z.object({
    id: z.literal(5),
    name: z.string().optional(),
    name2: z.literal("failed"),
  }),
  partially_paid: z.object({
    id: z.literal(6),
    name: z.string().optional(),
    name2: z.literal("partially_paid"),
  }),
  refunded: z.object({
    id: z.literal(7),
    name: z.string().optional(),
    name2: z.literal("refunded"),
  }),
  partially_refunded: z.object({
    id: z.literal(8),
    name: z.string().optional(),
    name2: z.literal("partially_refunded"),
  }),
  cancelled: z.object({
    id: z.literal(9),
    name: z.string().optional(),
    name2: z.literal("cancelled"),
  }),
});

export const fulfillOptionsEnumSchema = z.object({
  draft: z.object({
    id: z.literal(0),
    name2: z.literal("draft"),
    name: z.string().optional(),
  }),
  processing: z.object({
    id: z.literal(1),
    name2: z.literal("processing"),
    name: z.string().optional(),
  }),
  shipped: z.object({
    id: z.literal(2),
    name2: z.literal("shipped"),
    name: z.string().optional(),
  }),
  fulfilled: z.object({
    id: z.literal(3),
    name2: z.literal("fulfilled"),
    name: z.string().optional(),
  }),
  cancelled: z.object({
    id: z.literal(4),
    name2: z.literal("cancelled"),
    name: z.string().optional(),
  }),
});

export const taxRecordSchema = z.object({
  name: z.string().optional().describe("the name of the tax deduction"),
  description: z
    .string()
    .optional()
    .describe("the description of the tax deduction"),
  value: z.number().describe("The absolute value of tax to deduct"),
});

export const discountErrorSchema = z.object({
  discount_code: z.string().describe("`handle` of the discount"),
  message: z.string().describe("Error message"),
});

export const ordersStatisticsEntitySchema = z.record(z.any()).and(
  z.object({
    handle: z.string().optional().describe("`handle` of entity"),
    id: z.string().optional().describe("`id` of entity"),
    title: z.string().optional().describe("`title` of entity"),
    count: z
      .number()
      .optional()
      .describe("`count` of entity occurences in the day"),
  }),
);

export const ordersStatisticsDayMetricSchema = z.object({
  total_income: z
    .number()
    .optional()
    .describe("The total income in a day for a metric"),
  count: z
    .number()
    .optional()
    .describe("The `count` of orders in a day for a metric"),
});

export const ordersStatisticsDaySchema = z.object({
  metrics: z
    .object({
      payments_captured: ordersStatisticsDayMetricSchema.optional(),
      payments_failed: ordersStatisticsDayMetricSchema.optional(),
      payments_unpaid: ordersStatisticsDayMetricSchema.optional(),
      checkouts_created: ordersStatisticsDayMetricSchema.optional(),
      checkouts_completed: ordersStatisticsDayMetricSchema.optional(),
      fulfillment_draft: ordersStatisticsDayMetricSchema.optional(),
      fulfillment_shipped: ordersStatisticsDayMetricSchema.optional(),
      fulfillment_processing: ordersStatisticsDayMetricSchema.optional(),
      fulfillment_cancelled: ordersStatisticsDayMetricSchema.optional(),
    })
    .describe("metrics for many `order` statuses"),
  day: z
    .union([z.string(), z.number()])
    .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
  products: z
    .record(
      z
        .union([handleSchema, idSchema])
        .describe("The `products` found in all created orders"),
      ordersStatisticsEntitySchema.describe(
        "The `products` found in all created orders",
      ),
    )
    .optional()
    .describe("The `products` found in all created orders"),
  collections: z
    .record(
      z
        .union([handleSchema, idSchema])
        .describe("The `collections` found in all created orders"),
      ordersStatisticsEntitySchema.describe(
        "The `collections` found in all created orders",
      ),
    )
    .optional()
    .describe("The `collections` found in all created orders"),
  discounts: z
    .record(
      z
        .union([handleSchema, idSchema])
        .describe("The `discounts` found in all created orders"),
      ordersStatisticsEntitySchema.describe(
        "The `discounts` found in all created orders",
      ),
    )
    .optional()
    .describe("The `discounts` found in all created orders"),
  tags: z
    .record(
      z
        .union([handleSchema, idSchema])
        .describe("The `tags` found in all created orders `products`"),
      ordersStatisticsEntitySchema.describe(
        "The `tags` found in all created orders `products`",
      ),
    )
    .optional()
    .describe("The `tags` found in all created orders `products`"),
});

export const ordersStatisticsTypeSchema = z.object({
  days: z
    .record(
      z.union([z.number(), z.string()]).describe("The days statistics"),
      ordersStatisticsDaySchema.describe("The days statistics"),
    )
    .optional()
    .describe("The days statistics"),
  from_day: z
    .union([z.string(), z.number()])
    .optional()
    .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
  to_day: z
    .union([z.string(), z.number()])
    .optional()
    .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
  count_days: z
    .number()
    .optional()
    .describe("The count of days in `from_day` to `to_day`"),
});

export const configFieldSchema = z.object({
  key: z.string().describe("the `key` of the field"),
  value: z.any().optional().describe("the `value` of the field"),
  description: z.string().optional().describe("the `description` of the field"),
  name: z.string().describe("the `name` of the field"),
  editable: z.boolean().optional().describe("Is the field editable ?"),
  metadata: z
    .object({
      component: z.union([
        z.literal("select"),
        z.literal("input"),
        z.literal("label"),
        z.literal("textarea"),
      ]),
      params: z.any(),
    })
    .describe("The interface of the `field`"),
});

export const extensionInfoSchema = z.object({
  name: z.string().describe("name of the `extension`"),
  description: z.string().optional().describe("description of the `extension`"),
  logo_url: z
    .string()
    .optional()
    .describe("logo url (or even data-url) of the `extension`"),
  url: z.string().optional().describe("url of the extension website"),
});

export const extensionActionSchema = z.object({
  name: z.string().describe("action name for display"),
  handle: z.string().describe("action handle for invocation at backend"),
  description: z
    .string()
    .optional()
    .describe(
      "optional description of what will happen\nif the action is executed",
    ),
});

export const extensionItemGetSchema = z.object({
  info: extensionInfoSchema.describe(
    "The info such as `name`, `description` etc..",
  ),
  actions: z
    .array(extensionActionSchema)
    .describe("A list of `actions` supported by the `extension`"),
  config: z.any().describe("The extension's configuration"),
  handle: z.string().describe("The `handle` of the `extension`"),
});

export const paymentGatewayInfoSchema = extensionInfoSchema;

export const paymentGatewayActionSchema = extensionActionSchema.extend({
  parameters: z
    .array(configFieldSchema)
    .optional()
    .describe(
      "Action might have extra parameters,\nfor example a partial refund action, may specify a variable value\nfor refunding, also with some of the `capture` actions,\nwhich may capture less than intended.",
    ),
});

export const paymentGatewayStatusSchema = z.object({
  actions: z
    .array(paymentGatewayActionSchema)
    .optional()
    .describe("List of possible actions to take"),
  messages: z
    .array(z.string())
    .optional()
    .describe(
      "A list of messages of the current payment status,\nfor example `150$ were authorized...`",
    ),
});

export const paymentGatewayItemGetSchema = z.object({
  info: paymentGatewayInfoSchema.describe(
    "The info such as `name`, `description` etc..",
  ),
  actions: z
    .array(paymentGatewayActionSchema)
    .describe("A list of `actions` supported by the gateway"),
  config: z.any().describe("The gateway's configuration"),
  handle: z.string().describe("The `handle` of the `gateway`"),
});

export const templateTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("`handle`"),
  title: z.string().describe("`title` of `template`"),
  template_html: z
    .string()
    .optional()
    .describe("The **HTML** `template` `handlebars` string"),
  template_text: z
    .string()
    .optional()
    .describe("The **TEXT** `template` `handlebars` string"),
  reference_example_input: z
    .any()
    .optional()
    .describe("A reference example input for the template"),
});

export const templateTypeUpsertSchema = templateTypeSchema
  .omit({ id: true, handle: true })
  .extend(withOptionalHandleOrIDSchema.shape);

export const quickSearchResourceSchema = z.object({
  id: z.string(),
  handle: z.string().optional(),
  title: z.string().optional(),
});

export const tablesSchema = z
  .union([
    z.literal("auth_users"),
    z.literal("tags"),
    z.literal("collections"),
    z.literal("customers"),
    z.literal("products"),
    z.literal("storefronts"),
    z.literal("images"),
    z.literal("posts"),
    z.literal("templates"),
    z.literal("shipping_methods"),
    z.literal("notifications"),
    z.literal("discounts"),
    z.literal("orders"),
    z.literal("search"),
  ])
  .describe("full result of quick search");

export const quickSearchResultSchema = z.record(
  z.union([tablesSchema, z.string()]),
  z.array(quickSearchResourceSchema),
);

export const storecraftConfigSchema = z.object({
  general_store_name: z
    .string()
    .optional()
    .describe(
      "The store name\n`platform.env.SC_GENERAL_STORE_NAME` environment",
    ),
  general_store_website: z
    .string()
    .optional()
    .describe(
      "The store `website`\n`platform.env.SC_GENERAL_STORE_WEBSITE` environment",
    ),
  general_store_logo_url: z
    .string()
    .optional()
    .describe(
      "The store `logo` url\n`platform.env.SC_GENERAL_STORE_LOGO_URL` environment",
    ),
  general_store_description: z
    .string()
    .optional()
    .describe(
      "The store `description`\n`platform.env.SC_GENERAL_STORE_DESCRIPTION` environment",
    ),
  general_store_support_email: z
    .string()
    .optional()
    .describe(
      "The store support email\n`platform.env.SC_GENERAL_STORE_SUPPORT_EMAIL` environment",
    ),
  general_confirm_email_base_url: z
    .string()
    .optional()
    .describe(
      "The store `email-confirm` base url into which a template\naction button will link into including a `token` as a query parameter.\n\n### For example:\nSuppose the base url is `https://store.com/confirm`,\nthen `storecraft` default email template will use this to send\na link with `https://store.com/confirm?token{{CONFIRM_TOKEN}}`\n\nYou can use this to delegate into `storecraft` auth backend endpoint\n`/api/auth/confirm-email?token{{CONFIRM_TOKEN}}`",
    )
    .default(
      "`platform.env.SC_GENERAL_STORE_CONFIRM_EMAIL_BASE_URL` environment",
    ),
  general_forgot_password_confirm_base_url: z
    .string()
    .optional()
    .describe(
      "The store `forgot-password` base url, into which template action\nbutton will link into including a `token` as a query parameter.\n\n### For example:\nSuppose the base url is `https://store.com/forgot-password-confirm`,\nthen `storecraft` default email template will use this to send\na link with `https://store.com/forgot-password-confirm?token{{CONFIRM_TOKEN}}`\n\nYou can use this to delegate into `storecraft` auth backend endpoint\n`/api/auth/forgot-password-request-confirm?token{{CONFIRM_TOKEN}}`",
    )
    .default(
      "`platform.env.SC_GENERAL_STORE_FORGOT_PASSWORD_CONFIRM_BASE_URL` environment",
    ),
  auth_admins_emails: z
    .array(z.string())
    .optional()
    .describe(
      "Seed admin emails, if absent will be infered at init by\n`platform.env.SC_AUTH_ADMIN_EMAILS` environment as CSV of emails",
    ),
  auth_secret_access_token: z
    .string()
    .describe(
      "access token signing secret, if absent will be infered\nat init by `platform.env.SC_AUTH_SECRET_ACCESS_TOKEN` environment",
    ),
  auth_secret_refresh_token: z
    .string()
    .describe(
      "refresh token signing secret, if absent will be infered at\ninit by `platform.env.SC_AUTH_SECRET_REFRESH_TOKEN` environment",
    ),
  checkout_reserve_stock_on: z
    .union([
      z.literal("checkout_create"),
      z.literal("checkout_complete"),
      z.literal("never"),
    ])
    .optional()
    .describe(
      "(Optional) automatically reserve stock, we recommend to use `never`.\nDepending on your needs you can alter this setting.\nif absent will be infered at init by `platform.env.SC_CHECKOUT_RESERVE_STOCK_ON`\nenvironment and then will default to `never`.",
    )
    .default("never"),
  storage_rewrite_urls: z
    .string()
    .optional()
    .describe(
      "(Optional) Once object `storage` is used, you may have connected a\n**CDN** to buckets to take advantage of faster assets serving instead of serving\nfrom your server / the storage service directly. If you are using an cloud based\nstorage service such as AWS S3, it is very recommended to attach the bucket to\na **CDN** for super fast and efficient serving.\n\nTake note, most cloud based storage services and `storecraft` drivers support creating\n`presigned` urls for `download` / `upload`, which essentially delegate these operations\nto the storage services. However, **CDN** is always the best choice for assets serving\ncost and latency wise.\n\nif absent will be infered at init by `platform.env.SC_STORAGE_REWRITE_URLS` environment.",
    )
    .default("undefined"),
  cors: cORSOptionsSchema
    .optional()
    .describe(
      "(Optional) Your chance to override the default `CORS` config\nfor HTTP requests",
    ),
});

export const authUserTypeSchema = baseTypeSchema
  .omit({ id: true })
  .extend(authBaseTypeSchema.shape)
  .extend({
    id: z.string().describe("ID"),
    confirmed_mail: z.boolean().optional().describe("Is the email confirmed ?"),
    roles: z
      .array(roleSchema)
      .optional()
      .describe("list of roles and authorizations of the user"),
    tags: z.array(z.string()).optional().describe("tags"),
    firstname: z
      .string()
      .optional()
      .describe("(optional) readable `name` of `customer`"),
    lastname: z
      .string()
      .optional()
      .describe("(optional) readable `name` of `customer`"),
  });

export const buyXGetYDiscountExtraSchema = z.object({
  fixed: z
    .number()
    .describe("`BuyXGetYDiscountExtra` params, Fixed price addition"),
  percent: z.number().describe("`BuyXGetYDiscountExtra` params, Percents off"),
  qty_x: z
    .number()
    .describe("`BuyXGetYDiscountExtra` params, The integer\nquantity of BUY X"),
  qty_y: z
    .number()
    .describe("`BuyXGetYDiscountExtra` params, The integer quantity\nof BUY Y"),
  filters_y: z
    .array(filterSchema)
    .describe(
      "`BuyXGetYDiscountExtra` params, The filters for what\na customer gets (Y)",
    ),
  recursive: z
    .boolean()
    .optional()
    .describe(
      "`BuyXGetYDiscountExtra` params, Apply the discount\nas many times as possible",
    ),
});

export const notificationActionSchema = z.object({
  name: z.string().optional().describe("Name of the action"),
  interface: notificationActionTypeSchema
    .optional()
    .describe("The interface of action"),
  params: z
    .union([
      notificationActionRouteParamsSchema,
      notificationActionUrlParamsSchema,
    ])
    .optional()
    .describe("Extra params for the actions interface"),
});

const baseNotificationTypeSchema = z.object({
  message: z
    .string()
    .describe(
      "Message of notification, can be markdown,\nmarkup or plain text",
    ),
  author: z.string().optional().describe("Author of the notification"),
  actions: z
    .array(notificationActionSchema)
    .optional()
    .describe("List of actions"),
  search: z.array(z.string()).optional().describe("search terms"),
  id: z.string().describe("`id` of notification"),
});

export const notificationTypeUpsertSchema = baseNotificationTypeSchema.omit({
  id: true,
});

export const orderStatusSchema = z.object({
  checkout: z
    .union([
      checkoutStatusEnumSchema.shape.complete,
      checkoutStatusEnumSchema.shape.created,
      checkoutStatusEnumSchema.shape.failed,
      checkoutStatusEnumSchema.shape.requires_action,
      checkoutStatusEnumSchema.shape.unknown,
    ])
    .describe("`checkout` status"),
  payment: z
    .union([
      paymentOptionsEnumSchema.shape.authorized,
      paymentOptionsEnumSchema.shape.captured,
      paymentOptionsEnumSchema.shape.failed,
      paymentOptionsEnumSchema.shape.partially_paid,
      paymentOptionsEnumSchema.shape.partially_refunded,
      paymentOptionsEnumSchema.shape.refunded,
      paymentOptionsEnumSchema.shape.requires_auth,
      paymentOptionsEnumSchema.shape.unpaid,
      paymentOptionsEnumSchema.shape.voided,
    ])
    .describe("`payment` status"),
  fulfillment: z
    .union([
      fulfillOptionsEnumSchema.shape.cancelled,
      fulfillOptionsEnumSchema.shape.draft,
      fulfillOptionsEnumSchema.shape.fulfilled,
      fulfillOptionsEnumSchema.shape.processing,
      fulfillOptionsEnumSchema.shape.shipped,
    ])
    .describe("`fulfillment` status"),
});

export const orderPaymentGatewayDataSchema = z.object({
  gateway_handle: z.string().describe("The payment gateway identifier"),
  on_checkout_create: z
    .any()
    .optional()
    .describe(
      "Result of gateway at checkout creation, this will later be given\nto the `payment gateway` on any interaction, which will use it to identify the payment.",
    ),
  on_checkout_complete: z
    .any()
    .optional()
    .describe(
      "Result of gateway at checkout completion, this will be used\nfor debugging purposes and observability.",
    ),
  latest_status: paymentGatewayStatusSchema
    .optional()
    .describe("Latest status of payment for caching"),
});

export const discountDetailsSchema = z.object({
  meta: z
    .union([
      discountMetaEnumSchema.shape.regular,
      discountMetaEnumSchema.shape.bulk,
      discountMetaEnumSchema.shape.bundle,
      discountMetaEnumSchema.shape.buy_x_get_y,
      discountMetaEnumSchema.shape.order,
    ])
    .describe("metadata to identify the interface of discount"),
  extra: z
    .union([
      regularDiscountExtraSchema,
      orderDiscountExtraSchema,
      bulkDiscountExtraSchema,
      buyXGetYDiscountExtraSchema,
      bundleDiscountExtraSchema,
    ])
    .describe("Extra parameters of the specific discount interface"),
});

export const notificationTypeSchema = baseNotificationTypeSchema.extend(
  timestampsSchema.shape,
);

export const discountInfoSchema = z.object({
  details: discountDetailsSchema.describe(
    "Discount details, decribes the `discount` interface and more",
  ),
  filters: z
    .array(filterSchema)
    .min(1, "You should Specify at least 1 Filter")
    .describe("List of `discount` filters"),
});

export const discountTypeSchema = baseTypeSchema.extend({
  active: z.boolean().describe("Is the discount active ?"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of discount"),
  handle: z.string().describe("Discount `code` / `handle`"),
  priority: z
    .number()
    .describe("The order in which to apply the discounts\nstack (priority)"),
  published: z
    .string()
    .optional()
    .describe(
      "Discounts may generate collections, this\nis the collection handle that contains the applicable\ndiscount products",
    ),
  info: discountInfoSchema.describe("Details and filters of the discount"),
  application: z
    .union([
      discountApplicationEnumSchema.shape.Auto,
      discountApplicationEnumSchema.shape.Manual,
    ])
    .describe("Discount application (`automatic` and `manual`)"),
});

export const baseProductTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("The readable unique product `handle`"),
  isbn: z
    .string()
    .optional()
    .describe("The International Standard Book Number (`ISBN`)"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of the product"),
  active: z.boolean().describe("Is the product active ?"),
  video: z.string().optional().describe("Video media url"),
  price: z.number().min(0).describe("Price of the product"),
  qty: z.number().min(0).describe("Integer stock quantity of product"),
  compare_at_price: z
    .number()
    .min(0)
    .optional()
    .describe("Compare at price point"),
  collections: z
    .array(collectionTypeSchema)
    .optional()
    .describe("Collections this product belongs to, expanded field"),
  discounts: z
    .array(discountTypeSchema)
    .optional()
    .describe(
      "Discounts we know were applied to this product,\nexpanded interface",
    ),
});

export const variantTypeSchema = baseProductTypeSchema.extend({
  parent_handle: z
    .string()
    .describe("Handle of parent product in case this\nproduct is a variant"),
  parent_id: z
    .string()
    .describe("`id` of parent product in case this\nproduct is a variant"),
  variant_hint: z
    .array(variantOptionSelectionSchema)
    .describe("Internal usage, clarifies the variant\nprojected options"),
  related_products: z
    .array(baseProductTypeSchema)
    .optional()
    .describe(
      "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
    ),
});

export const productTypeSchema = baseProductTypeSchema.extend({
  variants: z
    .array(variantTypeSchema)
    .optional()
    .describe("Product variants, expanded interface"),
  variants_options: z
    .array(variantOptionSchema)
    .optional()
    .describe("Variants options info"),
  related_products: z
    .array(baseProductTypeSchema)
    .optional()
    .describe(
      "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
    ),
});

export const productTypeUpsertSchema = productTypeSchema
  .omit({
    collections: true,
    related_products: true,
    discounts: true,
    variants: true,
    id: true,
    handle: true,
  })
  .extend(withOptionalHandleOrIDSchema.shape)
  .extend({
    collections: z
      .array(handleAndIDSchema)
      .optional()
      .describe(
        "List of collections to add the product into,\nthis is an explicit connection, to form a better UX experience",
      ),
    related_products: z
      .array(handleAndIDSchema)
      .optional()
      .describe(
        "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
      ),
  });

export const discountTypeUpsertSchema = discountTypeSchema
  .omit({ id: true, handle: true })
  .extend(withOptionalHandleOrIDSchema.shape);

export const storefrontTypeSchema = baseTypeSchema.extend({
  active: z.boolean().describe("Is the entity active ?"),
  handle: z.string().describe("Readable `handle`"),
  title: z.string().min(3, "Title should be longer than 3").describe("Title"),
  video: z.string().optional().describe("Video url"),
  published: z
    .string()
    .optional()
    .describe(
      "Storefronts may be exported to `json` for CDN,\nthis is the `url`",
    ),
  collections: z
    .array(collectionTypeSchema)
    .optional()
    .describe("Collections related to this storefront"),
  products: z
    .array(productTypeSchema)
    .optional()
    .describe("Products related to this storefront"),
  shipping_methods: z
    .array(shippingMethodTypeSchema)
    .optional()
    .describe("Shipping methods related to this storefront"),
  discounts: z
    .array(discountTypeSchema)
    .optional()
    .describe("Discounts related to this storefront"),
  posts: z
    .array(postTypeSchema)
    .optional()
    .describe("Posts related to this storefront"),
});

export const storefrontTypeUpsertSchema = storefrontTypeSchema
  .omit({
    collections: true,
    products: true,
    posts: true,
    discounts: true,
    shipping_methods: true,
    id: true,
    handle: true,
  })
  .extend(withOptionalHandleOrIDSchema.shape)
  .extend({
    collections: z
      .array(handleAndIDSchema)
      .optional()
      .describe("Collections related to this storefront"),
    products: z
      .array(handleAndIDSchema)
      .optional()
      .describe("Products related to this storefront"),
    shipping_methods: z
      .array(handleAndIDSchema)
      .optional()
      .describe("Shipping methods related to this storefront"),
    discounts: z
      .array(handleAndIDSchema)
      .optional()
      .describe("Discounts related to this storefront"),
    posts: z
      .array(handleAndIDSchema)
      .optional()
      .describe("Posts related to this storefront"),
  });

export const lineItemSchema = z.object({
  id: z.string().describe("`id` or `handle` of product"),
  price: z
    .number()
    .optional()
    .describe("Product unit price snapshot, if absent, try `data.price`"),
  qty: z
    .number()
    .describe("Integer quantity of how many such products\nwere bought"),
  stock_reserved: z
    .number()
    .optional()
    .describe(
      "Used by order to indicate it has reserved stock\nand it's amount",
    ),
  data: productTypeSchema
    .optional()
    .describe("(optional) the product data snapshot for\nfuture integrity"),
});

export const baseCheckoutCreateTypeSchema = z.object({
  id: z
    .string()
    .optional()
    .describe("`ID` in case we are converting a draft order to a checkout"),
  contact: orderContactSchema.optional().describe("Buyer info"),
  address: addressTypeSchema.optional().describe("Shipping address info"),
  line_items: z
    .array(lineItemSchema)
    .describe("Line items is a list of the purchased products"),
  notes: z.string().optional().describe("Notes for the order"),
  shipping_method: shippingMethodTypeSchema
    .partial()
    .describe("Shipping method info"),
});

export const checkoutCreateTypeSchema = baseCheckoutCreateTypeSchema.extend({
  coupons: z
    .array(discountTypeSchema)
    .optional()
    .describe("A list of manual coupons handles"),
});

const checkoutCreateTypeWithoutIDSchema = checkoutCreateTypeSchema.omit({
  id: true,
});

export const evoEntrySchema = z.object({
  discount_code: z.string().optional().describe("The discount code `handle`"),
  discount: discountTypeSchema.optional().describe("The `discount`"),
  total_discount: z
    .number()
    .optional()
    .describe(
      "The amount of money that was discounted\nby this discount at the current stage.",
    ),
  quantity_undiscounted: z
    .number()
    .optional()
    .describe("How many items are left to discount"),
  quantity_discounted: z
    .number()
    .optional()
    .describe("How many items were discounted now"),
  subtotal: z
    .number()
    .optional()
    .describe(
      "Running subtotal (from the beginning of all time) without shipping",
    ),
  total: z
    .number()
    .optional()
    .describe("Running total (from the beginning of all time)"),
  line_items_next: z
    .array(lineItemSchema)
    .optional()
    .describe("Available line items, that were not eligible for this discount"),
  line_items_discounted: z
    .array(lineItemSchema)
    .optional()
    .describe("The line items, that were discounted"),
});

export const similaritySearchResultSchema = z.object({
  score: z.number().describe("The score of similarity, lower is better"),
  namespace: z
    .union([
      z.literal("products"),
      z.literal("discounts"),
      z.literal("collections"),
      z.literal("shipping"),
    ])
    .describe("The interface of the content"),
  content: z
    .union([
      productTypeSchema,
      discountTypeSchema,
      collectionTypeSchema,
      shippingMethodTypeSchema,
    ])
    .describe("The content"),
});

export const variantCombinationSchema = z.object({
  selection: z
    .array(variantOptionSelectionSchema)
    .describe("A list of selection of option and value"),
  product: productTypeSchema.describe(
    "The product data associated with this variant",
  ),
});

export const variantTypeUpsertSchema = variantTypeSchema
  .omit({
    collections: true,
    discounts: true,
    related_products: true,
    id: true,
    handle: true,
  })
  .extend(withOptionalHandleOrIDSchema.shape)
  .extend({
    collections: z
      .array(handleAndIDSchema)
      .optional()
      .describe(
        "List of collections to add the product into,\nthis is an explicit connection, to form a better UX experience",
      ),
    related_products: z
      .array(baseProductTypeSchema.pick({ id: true, handle: true }))
      .optional()
      .describe(
        "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
      ),
  });

export const pricingDataSchema = z.object({
  evo: z
    .array(evoEntrySchema)
    .optional()
    .describe("Explanation of how discounts stack and change pricing"),
  shipping_method: shippingMethodTypeSchema
    .partial()
    .optional()
    .describe("Selected shipping method"),
  taxes: z
    .array(taxRecordSchema)
    .optional()
    .describe("The taxes collected from the sale"),
  subtotal_undiscounted: z
    .number()
    .describe("Subtotal of items price before discounts"),
  subtotal_discount: z.number().describe("Sum of all discounts at all stages"),
  subtotal: z
    .number()
    .describe("`subtotal_undiscounted` - `subtotal_discount`"),
  total_without_taxes: z
    .number()
    .optional()
    .describe("`subtotal` + `shipping`"),
  total: z.number().describe("`subtotal` + `shipping` + `taxes`"),
  quantity_total: z.number().describe("How many items are eligible"),
  quantity_discounted: z.number().describe("How many items were discounted"),
  uid: z.string().optional().describe("Authentication user id"),
  errors: z.array(discountErrorSchema).optional().describe("Errors"),
});

export const orderDataSchema = checkoutCreateTypeWithoutIDSchema
  .extend(baseTypeSchema.shape)
  .extend({
    status: orderStatusSchema.describe(
      "Status of `checkout`, `fulfillment` and `payment`",
    ),
    pricing: pricingDataSchema.describe("Pricing information"),
    validation: z
      .array(validationEntrySchema)
      .optional()
      .describe("In case the order went through validation"),
    payment_gateway: orderPaymentGatewayDataSchema
      .optional()
      .describe("Payment gateway info and status"),
  });

export const orderDataUpsertSchema = orderDataSchema
  .omit({ id: true })
  .extend(withOptionalHandleOrIDSchema.shape);
