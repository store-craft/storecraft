// Generated by ts-to-zod
import { z } from "zod";
export const errorItemSchema = z.object({
  message: z.string().optional(),
  code: z.string().optional(),
  expected: z.string().optional(),
  received: z.string().optional(),
  path: z.array(z.string()).optional(),
});
export const errorSchema = z.object({
  messages: z.array(errorItemSchema).optional(),
});
export const handleSchema = z.string();
export const idSchema = z.string();
export const timestampsSchema = z
  .object({
    created_at: z.string().optional().describe("ISO string creation time"),
    updated_at: z.string().optional().describe("ISO string update time"),
  })
  .describe("Timestamps");
export const searchableSchema = z
  .object({
    search: z.array(z.string()).optional(),
  })
  .describe("searchable");
export const idableSchema = z
  .object({
    id: z.string().optional().describe("ID"),
  })
  .describe("with `id`");
export const attributeTypeSchema = z
  .object({
    key: z.string().describe("The key"),
    value: z.string().optional().describe("The value"),
  })
  .describe("Attribute type, a key/value storage");
const jWTClaimsSchema = z.object({
  iss: z.string(),
  sub: z.string(),
  aud: z.string(),
  exp: z.number(),
  nbf: z.number(),
  iat: z.number(),
  jti: z.string(),
  roles: z.array(z.string()).describe("User roles and authorizations"),
});
export const authBaseTypeSchema = z
  .object({
    email: z.string().email().describe("Email of user"),
    password: z.string().min(4).max(20).describe("password"),
  })
  .describe("Auth base type");
export const roleSchema = z
  .union([z.literal("admin"), z.literal("user"), z.string()])
  .describe("Role of authenticated user");
export const apiAuthSigninTypeSchema =
  authBaseTypeSchema.describe("Sign in type");
export const apiAuthSignupTypeSchema =
  authBaseTypeSchema.describe("Sign up type");
export const apiAuthRefreshTypeSchema = z
  .object({
    refresh_token: z.string().describe("A refresh token"),
  })
  .describe("Refresh token input type");
export const apiTokenWithClaimsSchema = z
  .object({
    token: z.string().describe("a token (`access` or `refresh`)"),
    claims: jWTClaimsSchema
      .partial()
      .describe("Claims the `JSON Web Token` holds"),
  })
  .describe("API token with parsed claims");
export const apiKeyResultSchema = z
  .object({
    apikey: z
      .string()
      .describe(
        "The `apikey` is `base64_uri(apikey@storecraft.api:{password})`.\nIt will be shown only once to the user, at the `backend`, the password hash\nwill be saved, thus, the real password is only known to the user.",
      ),
  })
  .describe("Result of `auth` `apikey` creation");
export const apiAuthResultSchema = z
  .object({
    token_type: z
      .string()
      .describe("The type of token, should be `bearer` or `refresh`"),
    user_id: z.string().describe("the `ID` of user, example `au_....`"),
    access_token: apiTokenWithClaimsSchema.describe("The access token"),
    refresh_token: apiTokenWithClaimsSchema.describe("The refresh token"),
  })
  .describe("Result of `auth` request");
export const tagTypeSchema = idableSchema
  .extend(timestampsSchema.shape)
  .extend({
    handle: z.string().describe("The key name"),
    values: z.array(z.string()).describe("List of values, related to the key"),
  });
export const tagTypeUpsertSchema = tagTypeSchema.describe("Tag upsert type");
export const variantOptionSelectionSchema = z
  .object({
    option_id: z.string().describe("Variant option id"),
    value_id: z.string().describe("Variant selected value id"),
  })
  .describe("Variant option selection type");
export const textEntitySchema = z
  .object({
    id: z.string().describe("The `id` of the entity"),
    value: z.string().describe("The text value of the entity"),
  })
  .describe("Identifiable text entity type");
export const discountApplicationEnumSchema = z
  .object({
    Auto: z.object({
      id: z.literal(0),
      name: z.literal("Automatic"),
      name2: z.literal("automatic"),
    }),
    Manual: z.object({
      id: z.literal(1),
      name: z.literal("Manual"),
      name2: z.literal("manual"),
    }),
  })
  .describe(
    "Discounts can be manual(coupon) or automatic types,\nsee <a href='#DiscountApplicationEnum'>#DiscountApplicationEnum</a>",
  );
export const filterValuePInCollectionsSchema = z
  .array(
    z.object({
      id: z
        .string()
        .optional()
        .describe("`p_in_collections` filter, `id` of collection"),
      handle: z.string().optional(),
    }),
  )
  .describe("Filter for product in collections");
export const filterValuePNotInCollectionsSchema = z
  .array(
    z.object({
      id: z
        .string()
        .optional()
        .describe("`p_not_in_collections` filter, `id` of collection"),
      handle: z.string().optional(),
    }),
  )
  .describe("Filter for product not in collections");
export const filterValuePInHandlesSchema = z
  .array(z.string())
  .describe("Filter for product discount, product in handles");
export const filterValuePNotInHandlesSchema = z
  .array(z.string())
  .describe("Filter for product discount, product not in handles");
export const filterValuePInTagsSchema = z
  .array(z.string())
  .describe("Filter for product discount, product has tags");
export const filterValuePNotInTagsSchema = z
  .array(z.string())
  .describe("Filter for product discount, NOT has tags");
export const filterValuePAllSchema = z
  .any()
  .describe("Filter for product discount,\nthat chooses all products");
export const filterValuePInPriceRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`p_in_price_range` filter From price"),
    to: z.number().describe("`p_in_price_range` filter To price"),
  })
  .describe("Filter for product discount, product in price range");
export const filterValueOSubtotalInRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`o_subtotal_in_range` filter From price"),
    to: z.number().describe("`o_subtotal_in_range` filter To price"),
  })
  .describe("Filter for order discount, subtotal in range");
export const filterValueOItemsCountInRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`o_items_count_in_range` filter From count"),
    to: z.number().describe("`o_items_count_in_range` filter To count"),
  })
  .describe("Filter for order discount, items count in range");
export const filterValueODateInRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`o_date_in_range` filter From date timestamp"),
    to: z.number().describe("`o_date_in_range` filter To date timestamp"),
  })
  .describe("Filter for order discount, subtotal in range");
export const filterValueOHasCustomersSchema = z
  .array(z.string())
  .describe("Filter for order discount, order has customer id");
export const filterMetaEnumSchema = z.object({
  p_in_collections: z.object({
    id: z.literal(0),
    type: z.literal("product"),
    op: z.literal("p-in-collections"),
    name: z.literal("Product In Collection"),
  }),
  p_not_in_collections: z.object({
    id: z.literal(1),
    type: z.literal("product"),
    op: z.literal("p-not-in-collections"),
    name: z.literal("Product not in Collection"),
  }),
  p_in_handles: z.object({
    id: z.literal(2),
    type: z.literal("product"),
    op: z.literal("p-in-handles"),
    name: z.literal("Product has ID"),
  }),
  p_not_in_handles: z.object({
    id: z.literal(3),
    type: z.literal("product"),
    op: z.literal("p-not-in-handles"),
    name: z.literal("Product excludes ID"),
  }),
  p_in_tags: z.object({
    id: z.literal(4),
    type: z.literal("product"),
    op: z.literal("p-in-tags"),
    name: z.literal("Product has Tag"),
  }),
  p_not_in_tags: z.object({
    id: z.literal(5),
    type: z.literal("product"),
    op: z.literal("p-not-in-tags"),
    name: z.literal("Product excludes Tag"),
  }),
  p_all: z.object({
    id: z.literal(6),
    type: z.literal("product"),
    op: z.literal("p-all"),
    name: z.literal("All Products"),
  }),
  p_in_price_range: z.object({
    id: z.literal(7),
    type: z.literal("product"),
    op: z.literal("p-in-price-range"),
    name: z.literal("Product in Price range"),
  }),
  o_subtotal_in_range: z.object({
    id: z.literal(100),
    type: z.literal("order"),
    op: z.literal("o-subtotal-in-range"),
    name: z.literal("Order subtotal in range"),
  }),
  o_items_count_in_range: z.object({
    id: z.literal(101),
    type: z.literal("order"),
    op: z.literal("o-items-count-in-range"),
    name: z.literal("Order items count in range"),
  }),
  o_date_in_range: z.object({
    id: z.literal(102),
    type: z.literal("order"),
    op: z.literal("o-date-in-range"),
    name: z.literal("Order in dates"),
  }),
  o_has_customer: z.object({
    id: z.literal(103),
    type: z.literal("order"),
    op: z.literal("o-has-customer"),
    name: z.literal("Order has Customers"),
  }),
});
export const regularDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`RegularDiscountExtra` params, Fixed price addition"),
    percent: z.number().describe("`RegularDiscountExtra` params, Percents off"),
  })
  .describe("Parameters of a regular discount");
export const orderDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`OrderDiscountExtra` params, Fixed price addition"),
    percent: z.number().describe("`OrderDiscountExtra` params, Percents off"),
    free_shipping: z
      .boolean()
      .optional()
      .describe("`OrderDiscountExtra` params, Do we have free shipping ?"),
  })
  .describe("Parameters of order discount");
export const bulkDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`BulkDiscountExtra` params, Fixed price addition"),
    percent: z.number().describe("`BulkDiscountExtra` params, Percents off"),
    qty: z
      .number()
      .describe(
        "`BulkDiscountExtra` params, The integer quantity\nfor which the discount is given",
      ),
    recursive: z
      .boolean()
      .optional()
      .describe(
        "`BulkDiscountExtra` params, Apply the discount as\nmany times as possible",
      ),
  })
  .describe("Parameters of bulk discount");
export const bundleDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`BundleDiscountExtra` params, Fixed price addition"),
    percent: z.number().describe("`BundleDiscountExtra` params, Percents off"),
    recursive: z
      .boolean()
      .optional()
      .describe(
        "`BundleDiscountExtra` params, Apply the discount\nas many times as possible",
      ),
  })
  .describe("Parameters of bulk discount");
export const discountMetaEnumSchema = z
  .object({
    regular: z.object({
      id: z.literal(0),
      type: z.literal("regular"),
      name: z.literal("Regular Discount"),
    }),
    bulk: z.object({
      id: z.literal(1),
      type: z.literal("bulk"),
      name: z.literal("Bulk Discount"),
    }),
    buy_x_get_y: z.object({
      id: z.literal(2),
      type: z.literal("buy_x_get_y"),
      name: z.literal("Buy X Get Y"),
    }),
    order: z.object({
      id: z.literal(3),
      type: z.literal("order"),
      name: z.literal("Order Discount"),
    }),
    bundle: z.object({
      id: z.literal(4),
      type: z.literal("bundle"),
      name: z.literal("Bundle Discount"),
    }),
  })
  .describe(
    "Discount meta data,\nsee <a href='#DiscountMetaEnum'>#DiscountMetaEnum</a>",
  );
export const addressTypeSchema = z
  .object({
    firstname: z.string().optional().describe("First name of recipient"),
    lastname: z.string().optional().describe("Last name of recipient"),
    phone_number: z
      .string()
      .regex(/^([+]?d{1,2}[-s]?|)d{3}[-s]?d{3}[-s]?d{4}$ Invalid phone number/)
      .optional()
      .describe("The phone number of the recipient"),
    company: z
      .string()
      .optional()
      .describe("Optional company name of recipient"),
    street1: z.string().optional().describe("Street address 1"),
    street2: z.string().optional().describe("Street address 2"),
    city: z.string().optional().describe("City"),
    country: z.string().optional().describe("Country"),
    state: z.string().optional().describe("State"),
    zip_code: z.string().optional().describe("ZIP code"),
    postal_code: z.string().optional().describe("Postal code"),
  })
  .describe("Address type");
export const notificationActionTypeSchema = z
  .union([z.literal("route"), z.literal("url")])
  .describe(
    "'route' means routing inside admin panel 'url' is linking to a url",
  );
export const notificationActionRouteParamsSchema = z
  .object({
    collection: z.string().describe("Which collection"),
    document: z.string().describe("Which document"),
  })
  .describe("route inside admin panel action params");
export const notificationActionUrlParamsSchema = z
  .object({
    new_window: z.boolean().optional().describe("Ppen the url in new window"),
    url: z.string().describe("The url to open"),
  })
  .describe("Action params for actions of type 'url'");
export const orderContactSchema = z
  .object({
    firstname: z.string().optional().describe("First name"),
    lastname: z.string().optional().describe("Last name"),
    phone_number: z.string().optional().describe("Phone number"),
    email: z.string().optional().describe("Email"),
    customer_id: z.string().optional().describe("Customer `id`"),
  })
  .describe("Order buyer info");
export const validationEntrySchema = z
  .object({
    id: z.string().describe("`id`"),
    title: z
      .string()
      .min(3, "Title should be longer than 3")
      .optional()
      .describe("title"),
    message: z
      .union([
        z.literal("out-of-stock"),
        z.literal("not-enough-stock"),
        z.literal("some-stock-is-on-hold"),
      ])
      .optional()
      .describe("message"),
  })
  .describe(
    "Checkouts or draft orders might be validated\nin automatic systems",
  );
export const orderPaymentGatewayDataSchema = z
  .object({
    gateway_handle: z.string().describe("The payment gateway identifier"),
    on_checkout_create: z
      .any()
      .optional()
      .describe(
        "Result of gateway at checkout creation, this will later be given\nto the `payment gateway` on any interaction, which will use it to identify the payment.",
      ),
    latest_status: z
      .any()
      .optional()
      .describe("Latest status of payment for caching"),
  })
  .describe("How did the order interacted with a payment gateway ?");
export const fulfillOptionsEnumSchema = z
  .object({
    draft: z.object({
      id: z.literal(0),
      name2: z.literal("draft"),
      name: z.literal("Draft"),
    }),
    processing: z.object({
      id: z.literal(1),
      name2: z.literal("processing"),
      name: z.literal("Processing (Stock Reserved)"),
    }),
    shipped: z.object({
      id: z.literal(2),
      name2: z.literal("shipped"),
      name: z.literal("Shipped"),
    }),
    fulfilled: z.object({
      id: z.literal(3),
      name2: z.literal("fulfilled"),
      name: z.literal("Fulfilled"),
    }),
    cancelled: z.object({
      id: z.literal(4),
      name2: z.literal("cancelled"),
      name: z.literal("Cancelled (Stock returned)"),
    }),
  })
  .describe(
    "Fulfillment options encapsulate the current state,\nsee <a href='#FulfillOptionsEnum'>#FulfillOptionsEnum</a>",
  );
export const paymentOptionsEnumSchema = z
  .object({
    unpaid: z.object({
      id: z.literal(0),
      name: z.literal("Unpaid"),
      name2: z.literal("unpaid"),
    }),
    authorized: z.object({
      id: z.literal(1),
      name: z.literal("Authorized"),
      name2: z.literal("authorized"),
    }),
    captured: z.object({
      id: z.literal(2),
      name: z.literal("Captured"),
      name2: z.literal("captured"),
    }),
    requires_auth: z.object({
      id: z.literal(3),
      name: z.literal("Requires Authentication"),
      name2: z.literal("requires_auth"),
    }),
    voided: z.object({
      id: z.literal(4),
      name: z.literal("Voided"),
      name2: z.literal("voided"),
    }),
    failed: z.object({
      id: z.literal(5),
      name: z.literal("Failed"),
      name2: z.literal("failed"),
    }),
    partially_paid: z.object({
      id: z.literal(6),
      name: z.literal("Partially paid"),
      name2: z.literal("partially_paid"),
    }),
    refunded: z.object({
      id: z.literal(7),
      name: z.literal("Refunded"),
      name2: z.literal("refunded"),
    }),
    partially_refunded: z.object({
      id: z.literal(8),
      name: z.literal("Partially Refunded"),
      name2: z.literal("partially_refunded"),
    }),
  })
  .describe(
    "Payment options encapsulate the current state,\nsee <a href='#PaymentOptionsEnum'>#PaymentOptionsEnum</a>",
  );
export const checkoutStatusEnumSchema = z
  .object({
    created: z.object({
      id: z.literal(0),
      name2: z.literal("created"),
      name: z.literal("Created"),
    }),
    requires_action: z.object({
      id: z.literal(1),
      name2: z.literal("requires_action"),
      name: z.literal("Requires Action"),
    }),
    failed: z.object({
      id: z.literal(2),
      name2: z.literal("failed"),
      name: z.literal("Failed"),
    }),
    complete: z.object({
      id: z.literal(3),
      name2: z.literal("complete"),
      name: z.literal("Complete"),
    }),
    unknown: z.object({
      id: z.literal(4),
      name2: z.literal("unknown"),
      name: z.literal("Unknown"),
    }),
  })
  .describe(
    "Checkout status encapsulate the current state,\nsee <a href='#CheckoutStatusEnum'>#CheckoutStatusEnum</a>",
  );
export const discountErrorSchema = z
  .object({
    discount_code: z.string().describe("`handle` of the discount"),
    message: z.string().describe("Error message"),
  })
  .describe("Discount error type");
export const ordersStatisticsEntitySchema = z
  .record(z.any())
  .and(
    z.object({
      handle: z.string().optional().describe("`handle` of entity"),
      id: z.string().optional().describe("`id` of entity"),
      title: z.string().optional().describe("`title` of entity"),
      count: z
        .number()
        .optional()
        .describe("`count` of entity occurences in the day"),
    }),
  )
  .describe("Stats of an `entity` in a day");
export const ordersStatisticsDayMetricSchema = z.object({
  total_income: z
    .number()
    .optional()
    .describe("The total income in a day for a metric"),
  count: z
    .number()
    .optional()
    .describe("The `count` of orders in a day for a metric"),
});
export const ordersStatisticsDaySchema = z
  .object({
    metrics: z
      .object({
        payments_captured: ordersStatisticsDayMetricSchema.optional(),
        payments_failed: ordersStatisticsDayMetricSchema.optional(),
        payments_unpaid: ordersStatisticsDayMetricSchema.optional(),
        checkouts_created: ordersStatisticsDayMetricSchema.optional(),
        checkouts_completed: ordersStatisticsDayMetricSchema.optional(),
        fulfillment_draft: ordersStatisticsDayMetricSchema.optional(),
        fulfillment_shipped: ordersStatisticsDayMetricSchema.optional(),
        fulfillment_processing: ordersStatisticsDayMetricSchema.optional(),
        fulfillment_cancelled: ordersStatisticsDayMetricSchema.optional(),
      })
      .describe("metrics for many `order` statuses"),
    day: z
      .union([z.string(), z.number()])
      .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
    products: z
      .record(
        z
          .union([handleSchema, idSchema])
          .describe("The `products` found in all created orders"),
        ordersStatisticsEntitySchema.describe(
          "The `products` found in all created orders",
        ),
      )
      .optional()
      .describe("The `products` found in all created orders"),
    collections: z
      .record(
        z
          .union([handleSchema, idSchema])
          .describe("The `collections` found in all created orders"),
        ordersStatisticsEntitySchema.describe(
          "The `collections` found in all created orders",
        ),
      )
      .optional()
      .describe("The `collections` found in all created orders"),
    discounts: z
      .record(
        z
          .union([handleSchema, idSchema])
          .describe("The `discounts` found in all created orders"),
        ordersStatisticsEntitySchema.describe(
          "The `discounts` found in all created orders",
        ),
      )
      .optional()
      .describe("The `discounts` found in all created orders"),
    tags: z
      .record(
        z
          .union([handleSchema, idSchema])
          .describe("The `tags` found in all created orders `products`"),
        ordersStatisticsEntitySchema.describe(
          "The `tags` found in all created orders `products`",
        ),
      )
      .optional()
      .describe("The `tags` found in all created orders `products`"),
  })
  .describe("Stats of a day");
export const ordersStatisticsTypeSchema = z
  .object({
    days: z
      .record(
        z.union([z.number(), z.string()]).describe("The days statistics"),
        ordersStatisticsDaySchema.describe("The days statistics"),
      )
      .optional()
      .describe("The days statistics"),
    from_day: z
      .union([z.string(), z.number()])
      .optional()
      .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
    to_day: z
      .union([z.string(), z.number()])
      .optional()
      .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
    count_days: z
      .number()
      .optional()
      .describe("The count of days in `from_day` to `to_day`"),
  })
  .describe("`Statisitics` of requested days");
export const baseTypeSchema = idableSchema
  .extend(timestampsSchema.shape)
  .extend({
    media: z.array(z.string()).optional().describe("List of images urls"),
    attributes: z
      .array(attributeTypeSchema)
      .optional()
      .describe("List of attributes"),
    tags: z
      .array(z.string())
      .optional()
      .describe("List of tags , example ['genere_action', 'rated_M', ...]"),
    description: z.string().optional().describe("Rich description"),
    active: z.boolean().optional().describe("Is the entity active ?"),
  });
export const authUserTypeSchema = baseTypeSchema
  .and(authBaseTypeSchema)
  .and(
    z.object({
      confirmed_mail: z
        .boolean()
        .optional()
        .describe("Is the email confirmed ?"),
      roles: z
        .array(roleSchema)
        .optional()
        .describe("list of roles and authorizations of the user"),
    }),
  )
  .describe("Auth user type");
export const collectionTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("The handle of the entity"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of collection"),
  active: z.boolean().describe("Is the entity active ?"),
  published: z
    .string()
    .optional()
    .describe(
      "Collections can be exported into\njson with products, this is the url",
    ),
});
export const collectionTypeUpsertSchema = collectionTypeSchema.describe(
  "Collection upsert type",
);
export const variantOptionSchema = z
  .object({
    name: z.string().describe("Variant option name (for example 'Size')"),
    id: z.string().describe("Variant option id"),
    values: z
      .array(textEntitySchema)
      .describe(
        "Variant option values\n(for example `Small` / `Medium` / `Large` ..)",
      ),
  })
  .describe("The data of a variant option");
export const filterSchema = z
  .object({
    meta: z
      .union([
        filterMetaEnumSchema.shape.p_all,
        filterMetaEnumSchema.shape.p_in_collections,
        filterMetaEnumSchema.shape.p_not_in_collections,
        filterMetaEnumSchema.shape.p_in_tags,
        filterMetaEnumSchema.shape.p_not_in_tags,
        filterMetaEnumSchema.shape.p_in_handles,
        filterMetaEnumSchema.shape.p_not_in_handles,
        filterMetaEnumSchema.shape.o_date_in_range,
        filterMetaEnumSchema.shape.o_has_customer,
        filterMetaEnumSchema.shape.o_items_count_in_range,
        filterMetaEnumSchema.shape.o_subtotal_in_range,
      ])
      .describe("Meta data related to identifying the filter"),
    value: z
      .union([
        filterValuePInCollectionsSchema,
        filterValuePNotInCollectionsSchema,
        filterValuePInHandlesSchema,
        filterValuePNotInHandlesSchema,
        filterValuePInTagsSchema,
        filterValuePNotInTagsSchema,
        filterValuePAllSchema,
        filterValuePInPriceRangeSchema,
        filterValueOSubtotalInRangeSchema,
        filterValueOItemsCountInRangeSchema,
        filterValueODateInRangeSchema,
        filterValueOHasCustomersSchema,
      ])
      .optional()
      .describe("The filter params"),
  })
  .describe("Discount filter scheme");
export const buyXGetYDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`BuyXGetYDiscountExtra` params, Fixed price addition"),
    percent: z
      .number()
      .describe("`BuyXGetYDiscountExtra` params, Percents off"),
    qty_x: z
      .number()
      .describe(
        "`BuyXGetYDiscountExtra` params, The integer\nquantity of BUY X",
      ),
    qty_y: z
      .number()
      .describe(
        "`BuyXGetYDiscountExtra` params, The integer quantity\nof BUY Y",
      ),
    filters_y: z
      .array(filterSchema)
      .describe(
        "`BuyXGetYDiscountExtra` params, The filters for what\na customer gets (Y)",
      ),
    recursive: z
      .boolean()
      .optional()
      .describe(
        "`BuyXGetYDiscountExtra` params, Apply the discount\nas many times as possible",
      ),
  })
  .describe("Parameters of bulk discount");
export const shippingMethodTypeSchema = baseTypeSchema.extend({
  price: z
    .number()
    .min(0, "Please set a price >= 0")
    .describe("Shipping method price"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Name of shipping method"),
  handle: z.string().describe("Readable `handle` of shipping"),
});
export const postTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("Unique `handle`"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of post"),
  text: z.string().describe("Rich text of post"),
});
export const customerTypeSchema = baseTypeSchema.extend({
  auth_id: z
    .string()
    .optional()
    .describe(
      "The `auth id` of the customer. it is the same as\ncustomer `id` with `au` prefix instead",
    ),
  firstname: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("Firstname"),
  lastname: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("Lastname"),
  email: z.string().email().describe("Email of customer"),
  phone_number: z
    .string()
    .regex(/^([+]?d{1,2}[-s]?|)d{3}[-s]?d{3}[-s]?d{4}$/)
    .optional()
    .describe("The phone number"),
  address: addressTypeSchema.optional().describe("Address info of customer"),
});
export const customerTypeUpsertSchema = customerTypeSchema.describe(
  "Customer upsert type",
);
export const imageTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("Unique handle"),
  name: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("Name"),
  url: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("It's published public url"),
  usage: z
    .array(z.string())
    .optional()
    .describe("List of assets using this image"),
});
export const imageTypeUpsertSchema =
  imageTypeSchema.describe("Image upsert type");
export const shippingMethodTypeUpsertSchema = shippingMethodTypeSchema.describe(
  "Shipping upsert type",
);
export const postTypeUpsertSchema = postTypeSchema.describe("Post upsert type");
export const settingsTypeSchema = baseTypeSchema;
export const notificationActionSchema = z
  .object({
    name: z.string().optional().describe("Name of the action"),
    type: notificationActionTypeSchema
      .optional()
      .describe("The type of action"),
    params: z
      .union([
        notificationActionRouteParamsSchema,
        notificationActionUrlParamsSchema,
      ])
      .optional()
      .describe("Extra params for the actions type"),
  })
  .describe(
    "Each notification may have an actionable item\nassociated with it. For example, clicking an order notification\nwill route to the order page",
  );
export const orderStatusSchema = z
  .object({
    checkout: z
      .union([
        checkoutStatusEnumSchema.shape.complete,
        checkoutStatusEnumSchema.shape.created,
        checkoutStatusEnumSchema.shape.failed,
        checkoutStatusEnumSchema.shape.requires_action,
        checkoutStatusEnumSchema.shape.unknown,
      ])
      .describe("`checkout` status"),
    payment: z
      .union([
        paymentOptionsEnumSchema.shape.authorized,
        paymentOptionsEnumSchema.shape.captured,
        paymentOptionsEnumSchema.shape.failed,
        paymentOptionsEnumSchema.shape.partially_paid,
        paymentOptionsEnumSchema.shape.partially_refunded,
        paymentOptionsEnumSchema.shape.refunded,
        paymentOptionsEnumSchema.shape.requires_auth,
        paymentOptionsEnumSchema.shape.unpaid,
        paymentOptionsEnumSchema.shape.voided,
      ])
      .describe("`payment` status"),
    fulfillment: z
      .union([
        fulfillOptionsEnumSchema.shape.cancelled,
        fulfillOptionsEnumSchema.shape.draft,
        fulfillOptionsEnumSchema.shape.fulfilled,
        fulfillOptionsEnumSchema.shape.processing,
        fulfillOptionsEnumSchema.shape.shipped,
      ])
      .describe("`fulfillment` status"),
  })
  .describe("Status of `checkout`, `fulfillment` and `payment`");
export const discountDetailsSchema = z
  .object({
    meta: z
      .union([
        discountMetaEnumSchema.shape.regular,
        discountMetaEnumSchema.shape.bulk,
        discountMetaEnumSchema.shape.bundle,
        discountMetaEnumSchema.shape.buy_x_get_y,
        discountMetaEnumSchema.shape.order,
      ])
      .describe("metadata to identify the type of discount"),
    extra: z
      .union([
        regularDiscountExtraSchema,
        orderDiscountExtraSchema,
        bulkDiscountExtraSchema,
        buyXGetYDiscountExtraSchema,
        bundleDiscountExtraSchema,
      ])
      .describe("Extra parameters of the specific discount type"),
  })
  .describe(
    "The details of how to apply a discount.\nThe type of discount and it's params",
  );
const baseNotificationTypeSchema = z.object({
  message: z
    .string()
    .describe(
      "Message of notification, can be markdown,\nmarkup or plain text",
    ),
  author: z.string().optional().describe("Author of the notification"),
  actions: z
    .array(notificationActionSchema)
    .optional()
    .describe("List of actions"),
  search: z.array(z.string()).optional().describe("search terms"),
  id: z.string().optional().describe("`id` of notification"),
});
export const notificationTypeSchema = baseNotificationTypeSchema.extend(
  timestampsSchema.shape,
);
export const notificationTypeUpsertSchema = baseNotificationTypeSchema;
export const discountInfoSchema = z
  .object({
    details: discountDetailsSchema.describe(
      "Discount details, decribes the `discount` type and more",
    ),
    filters: z
      .array(filterSchema)
      .min(1, "You should Specify at least 1 Filter")
      .describe("List of `discount` filters"),
  })
  .describe("details and filters of the discount");
export const discountTypeSchema = baseTypeSchema.extend({
  active: z.boolean().describe("Is the discount active ?"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of discount"),
  handle: z.string().describe("Discount `code` / `handle`"),
  priority: z
    .number()
    .describe("The order in which to apply the discounts\nstack (priority)"),
  published: z
    .string()
    .optional()
    .describe(
      "Discounts may generate collections, this\nis the collection handle that contains the applicable\ndiscount products",
    ),
  info: discountInfoSchema.describe("Details and filters of the discount"),
  application: z
    .union([
      discountApplicationEnumSchema.shape.Auto,
      discountApplicationEnumSchema.shape.Manual,
    ])
    .describe("Discount application (`automatic` and `manual`)"),
});
export const discountTypeUpsertSchema = discountTypeSchema.describe(
  "Discount upsert type",
);
export const baseProductTypeSchema = baseTypeSchema.extend({
  handle: z
    .string()
    .optional()
    .describe("The readable unique product `handle`"),
  isbn: z
    .string()
    .optional()
    .describe("The International Standard Book Number (`ISBN`)"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of the product"),
  active: z.boolean().describe("Is the product active ?"),
  video: z.string().optional().describe("Video media url"),
  price: z.number().min(0).describe("Price of the product"),
  qty: z.number().min(0).describe("Integer stock quantity of product"),
  compare_at_price: z
    .number()
    .min(0)
    .optional()
    .describe("Compare at price point"),
  collections: z
    .array(collectionTypeSchema)
    .optional()
    .describe("Collections this product belongs to, expanded field"),
  discounts: z
    .array(discountTypeSchema)
    .optional()
    .describe("Discounts we know were applied to this product,\nexpanded type"),
});
export const variantTypeSchema = baseProductTypeSchema.extend({
  parent_handle: z
    .string()
    .describe("Handle of parent product in case this\nproduct is a variant"),
  parent_id: z
    .string()
    .describe("`id` of parent product in case this\nproduct is a variant"),
  variant_hint: z
    .array(variantOptionSelectionSchema)
    .describe("Internal usage, clarifies the variant\nprojected options"),
  related_products: z
    .array(baseProductTypeSchema)
    .optional()
    .describe(
      "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
    ),
});
export const variantTypeUpsertSchema = variantTypeSchema
  .omit({
    collections: true,
    published: true,
    discounts: true,
    related_products: true,
  })
  .and(
    z.object({
      collections: z
        .array(collectionTypeSchema.pick({ id: true, handle: true }))
        .optional()
        .describe(
          "List of collections to add the product into,\nthis is an explicit connection, to form a better UX experience",
        ),
      related_products: z
        .array(baseProductTypeSchema.pick({ id: true, handle: true }))
        .optional()
        .describe(
          "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
        ),
    }),
  )
  .describe("Variant upsert type");
export const productTypeSchema = baseProductTypeSchema.extend({
  variants: z
    .array(variantTypeSchema)
    .optional()
    .describe("Product variants, expanded type"),
  variants_options: z
    .array(variantOptionSchema)
    .optional()
    .describe("Variants options info"),
  related_products: z
    .array(baseProductTypeSchema)
    .optional()
    .describe(
      "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
    ),
});
export const productTypeUpsertSchema = productTypeSchema
  .omit({
    collections: true,
    published: true,
    related_products: true,
    discounts: true,
    variants: true,
  })
  .and(
    z.object({
      collections: z
        .array(collectionTypeSchema.pick({ id: true, handle: true }))
        .optional()
        .describe(
          "List of collections to add the product into,\nthis is an explicit connection, to form a better UX experience",
        ),
      related_products: z
        .array(baseProductTypeSchema.pick({ id: true, handle: true }))
        .optional()
        .describe(
          "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
        ),
    }),
  )
  .describe("Product upsert type");
export const storefrontTypeSchema = baseTypeSchema.extend({
  active: z.boolean().describe("Is the entity active ?"),
  handle: z.string().describe("Readable `handle`"),
  title: z.string().min(3, "Title should be longer than 3").describe("Title"),
  video: z.string().optional().describe("Video url"),
  published: z
    .string()
    .optional()
    .describe(
      "Storefronts may be exported to `json` for CDN,\nthis is the `url`",
    ),
  collections: z
    .array(collectionTypeSchema)
    .optional()
    .describe("Collections related to this storefront"),
  products: z
    .array(productTypeSchema)
    .optional()
    .describe("Products related to this storefront"),
  shipping_methods: z
    .array(shippingMethodTypeSchema)
    .optional()
    .describe("Shipping methods related to this storefront"),
  discounts: z
    .array(discountTypeSchema)
    .optional()
    .describe("Discounts related to this storefront"),
  posts: z
    .array(postTypeSchema)
    .optional()
    .describe("Posts related to this storefront"),
});
export const storefrontTypeUpsertSchema = storefrontTypeSchema.describe(
  "Storefront upsert type",
);
export const lineItemSchema = z
  .object({
    id: z.string().describe("`id` or `handle` of product"),
    price: z.number().optional().describe("Product price snapshot"),
    qty: z
      .number()
      .describe("Integer quantity of how many such products\nwere bought"),
    stock_reserved: z
      .number()
      .optional()
      .describe(
        "Used by order to indicate it has reserved stock\nand it's amount",
      ),
    data: productTypeSchema
      .optional()
      .describe("(optional) the product data snapshot for\nfuture integrity"),
  })
  .describe("A line item is a product, that appeared in an order");
export const evoEntrySchema = z
  .object({
    discount: discountTypeSchema.optional().describe("Discount at this step"),
    discount_code: z.string().optional().describe("The discount code `handle`"),
    total_discount: z
      .number()
      .optional()
      .describe("The amount of money that was discounted\nby this discount"),
    quantity_undiscounted: z
      .number()
      .optional()
      .describe("How many items are left to discount"),
    quantity_discounted: z
      .number()
      .optional()
      .describe("How many items were discounted now"),
    subtotal: z
      .number()
      .optional()
      .describe("Running subtotal without shipping"),
    total: z.number().optional().describe("Running total"),
    line_items: z
      .array(lineItemSchema)
      .optional()
      .describe("Available line items after discount"),
  })
  .describe(
    "Explains how a specific discount was used\nto discount line items",
  );
export const variantCombinationSchema = z
  .object({
    selection: z
      .array(variantOptionSelectionSchema)
      .describe("A list of selection of option and value"),
    product: productTypeSchema.describe(
      "The product data associated with this variant",
    ),
  })
  .describe("A tuple of option id and selected value id");
export const baseCheckoutCreateTypeSchema = z.object({
  contact: orderContactSchema.optional().describe("Buyer info"),
  address: addressTypeSchema.optional().describe("Shipping address info"),
  line_items: z
    .array(lineItemSchema)
    .describe("Line items is a list of the purchased products"),
  notes: z.string().optional().describe("Notes for the order"),
  shipping_method: shippingMethodTypeSchema.describe("Shipping method info"),
});
export const checkoutCreateTypeSchema = baseCheckoutCreateTypeSchema.extend({
  coupons: z
    .array(discountTypeSchema.shape.handle)
    .optional()
    .describe("A list of manual coupons handles"),
});
export const pricingDataSchema = z
  .object({
    evo: z
      .array(evoEntrySchema)
      .optional()
      .describe("Explanation of how discounts stack and change pricing"),
    shipping_method: shippingMethodTypeSchema
      .optional()
      .describe("Selected shipping method"),
    subtotal_undiscounted: z
      .number()
      .describe("Subtotal of items price before discounts"),
    subtotal_discount: z
      .number()
      .describe("Sum of all discounts at all stages"),
    subtotal: z
      .number()
      .describe("`subtotal_undiscounted` - `subtotal_discount`"),
    total: z.number().describe("`subtotal` + `shipping`"),
    quantity_total: z.number().describe("How many items are eligible"),
    quantity_discounted: z.number().describe("How many items were discounted"),
    uid: z.string().optional().describe("Authentication user id"),
    errors: z.array(discountErrorSchema).optional().describe("Errors"),
  })
  .describe(
    "Pricing object exaplins how the pricing of an order\nwas calculated given a stack of automatic discounts, coupons,\nline items and shipping method",
  );
export const orderDataSchema = baseCheckoutCreateTypeSchema
  .extend(baseTypeSchema.shape)
  .extend({
    status: orderStatusSchema.describe(
      "Status of `checkout`, `fulfillment` and `payment`",
    ),
    pricing: pricingDataSchema.describe("Pricing information"),
    validation: z
      .array(validationEntrySchema)
      .optional()
      .describe("In case the order went through validation"),
    payment_gateway: orderPaymentGatewayDataSchema
      .optional()
      .describe("Payment gateway info and status"),
    coupons: z
      .array(discountTypeSchema)
      .optional()
      .describe("A list of manual coupons snapshots that were used"),
  });
export const orderDataUpsertSchema =
  orderDataSchema.describe("Order upsert type");
