// Generated by ts-to-zod
import { z } from "zod";
export const storecraftConfigSchema = z
  .object({
    general_store_name: z
      .string()
      .optional()
      .describe(
        "The store name\n`platform.env.SC_GENERAL_STORE_NAME` environment",
      ),
    general_store_website: z
      .string()
      .optional()
      .describe(
        "The store `website`\n`platform.env.SC_GENERAL_STORE_WEBSITE` environment",
      ),
    general_store_logo_url: z
      .string()
      .optional()
      .describe(
        "The store `logo` url\n`platform.env.SC_GENERAL_STORE_LOGO_URL` environment",
      ),
    general_store_description: z
      .string()
      .optional()
      .describe(
        "The store `description`\n`platform.env.SC_GENERAL_STORE_DESCRIPTION` environment",
      ),
    general_store_support_email: z
      .string()
      .optional()
      .describe(
        "The store support email\n`platform.env.SC_GENERAL_STORE_SUPPORT_EMAIL` environment",
      ),
    general_confirm_email_base_url: z
      .string()
      .optional()
      .describe(
        "The store `email-confirm`\n`platform.env.SC_GENERAL_STORE_CONFIRM_EMAIL_BASE_URL` environment",
      ),
    auth_admins_emails: z
      .array(z.string())
      .optional()
      .describe(
        "Seed admin emails, if absent will be infered at init by\n`platform.env.SC_AUTH_ADMIN_EMAILS` environment as CSV of emails",
      ),
    auth_password_hash_rounds: z
      .number()
      .optional()
      .describe(
        "password hash rounds, if absent will be infered at init by\n`platform.env.SC_AUTH_PASS_HASH_ROUNDS` environment",
      ),
    auth_secret_access_token: z
      .string()
      .describe(
        "access token signing secret, if absent will be infered\nat init by `platform.env.SC_AUTH_SECRET_ACCESS_TOKEN` environment",
      ),
    auth_secret_refresh_token: z
      .string()
      .describe(
        "refresh token signing secret, if absent will be infered at\ninit by `platform.env.SC_AUTH_SECRET_REFRESH_TOKEN` environment",
      ),
    checkout_reserve_stock_on: z
      .union([
        z.literal("checkout_create"),
        z.literal("checkout_complete"),
        z.literal("never"),
      ])
      .optional()
      .describe(
        "(Optional) automatically reserve stock, we recommend to use `never`.\nDepending on your needs you can alter this setting.\nif absent will be infered at init by `platform.env.SC_CHECKOUT_RESERVE_STOCK_ON`\nenvironment and then will default to `never`.",
      )
      .default("never"),
    storage_rewrite_urls: z
      .string()
      .optional()
      .describe(
        "(Optional) Once object `storage` is used, you may have connected a\n**CDN** to buckets to take advantage of faster assets serving instead of serving\nfrom your server / the storage service directly. If you are using an cloud based\nstorage service such as AWS S3, it is very recommended to attach the bucket to\na **CDN** for super fast and efficient serving.\n\nTake note, most cloud based storage services and `storecraft` drivers support creating\n`presigned` urls for `download` / `upload`, which essentially delegate these operations\nto the storage services. However, **CDN** is always the best choice for assets serving\ncost and latency wise.\n\nif absent will be infered at init by `platform.env.SC_STORAGE_REWRITE_URLS` environment.",
      )
      .default("undefined"),
  })
  .describe("Basic config for `storecraft`");
export const errorItemSchema = z.object({
  message: z.string().optional(),
  code: z.string().optional(),
  expected: z.string().optional(),
  received: z.string().optional(),
  path: z.array(z.string()).optional(),
});
export const errorSchema = z.object({
  messages: z.array(errorItemSchema).optional(),
});
export const handleSchema = z.string();
export const idSchema = z.string();
export const timestampsSchema = z
  .object({
    created_at: z.string().optional().describe("ISO string creation time"),
    updated_at: z.string().optional().describe("ISO string update time"),
  })
  .describe("Timestamps");
export const searchableSchema = z
  .object({
    search: z.array(z.string()).optional(),
  })
  .describe("searchable");
export const idableSchema = z
  .object({
    id: z.string().optional().describe("ID"),
  })
  .describe("with `id`");
export const idableConcreteSchema = z
  .object({
    id: z.string().describe("ID"),
  })
  .describe("with `id`");
export const withOptionalHandleOrIDSchema = z.object({
  id: z.string().optional().describe("Optional `id`"),
  handle: z.string().optional().describe("Optional `handle`"),
});
export const attributeTypeSchema = z
  .object({
    key: z.string().describe("The key"),
    value: z.string().optional().describe("The value"),
  })
  .describe("Attribute type, a key/value storage");
const jWTClaimsSchema = z.object({
  iss: z.string(),
  sub: z.string(),
  aud: z.string(),
  exp: z.number(),
  nbf: z.number(),
  iat: z.number(),
  jti: z.string(),
  roles: z.array(z.string()).describe("User roles and authorizations"),
});
export const authBaseTypeSchema = z
  .object({
    email: z.string().email().describe("Email of user"),
    password: z.string().min(4).max(20).describe("password"),
  })
  .describe("Auth base type");
export const roleSchema = z
  .union([z.literal("admin"), z.literal("user"), z.string()])
  .describe("Role of authenticated user");
export const apiAuthSigninTypeSchema =
  authBaseTypeSchema.describe("Sign in type");
export const apiAuthSignupTypeSchema =
  authBaseTypeSchema.describe("Sign up type");
export const apiAuthChangePasswordTypeSchema = z
  .object({
    email: z.string().describe("User Email"),
    current_password: z.string().describe("Current password"),
    new_password: z.string().describe("New password"),
    confirm_new_password: z
      .string()
      .describe("Again New password for confirmation"),
  })
  .describe("Change Password Type");
export const apiAuthRefreshTypeSchema = z
  .object({
    refresh_token: z.string().describe("A refresh token"),
  })
  .describe("Refresh token input type");
export const apiTokenWithClaimsSchema = z
  .object({
    token: z.string().describe("a token (`access` or `refresh`)"),
    claims: jWTClaimsSchema
      .partial()
      .describe("Claims the `JSON Web Token` holds"),
  })
  .describe("API token with parsed claims");
export const apiKeyResultSchema = z
  .object({
    apikey: z
      .string()
      .describe(
        "The `apikey` is `base64_uri(apikey@storecraft.api:{password})`.\nIt will be shown only once to the user, at the `backend`, the password hash\nwill be saved, thus, the real password is only known to the user.",
      ),
  })
  .describe("Result of `auth` `apikey` creation");
export const apiAuthResultSchema = z
  .object({
    token_type: z
      .string()
      .describe("The type of token, should be `bearer` or `refresh`"),
    user_id: z.string().describe("the `ID` of user, example `au_....`"),
    access_token: apiTokenWithClaimsSchema.describe("The access token"),
    refresh_token: apiTokenWithClaimsSchema.describe("The refresh token"),
  })
  .describe("Result of `auth` request for `signin` / `signup` / `refresh`");
export const tagTypeSchema = idableSchema
  .extend(timestampsSchema.shape)
  .extend({
    handle: z.string().describe("The key name"),
    values: z.array(z.string()).describe("List of values, related to the key"),
  });
export const tagTypeUpsertSchema = tagTypeSchema
  .omit({ id: true, handle: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Tag upsert type");
export const variantOptionSelectionSchema = z
  .object({
    option_id: z.string().describe("Variant option id"),
    value_id: z.string().describe("Variant selected value id"),
  })
  .describe("Variant option selection type");
export const textEntitySchema = z
  .object({
    id: z.string().describe("The `id` of the entity"),
    value: z.string().describe("The text value of the entity"),
  })
  .describe("Identifiable text entity type");
export const handleAndIDSchema = z
  .object({
    id: z.string().describe("The `id` of the entity"),
    handle: z.string().describe("The `handle` of the entity"),
  })
  .describe("both `id` and `handle` of entity required");
export const discountApplicationEnumSchema = z
  .object({
    Auto: z.object({
      id: z.literal(0),
      name: z.string().optional(),
      name2: z.literal("automatic"),
    }),
    Manual: z.object({
      id: z.literal(1),
      name: z.string().optional(),
      name2: z.literal("manual"),
    }),
  })
  .describe(
    "Discounts can be manual(coupon) or automatic types,\nsee <a href='#DiscountApplicationEnum'>#DiscountApplicationEnum</a>",
  );
export const filterValuePInCollectionsSchema = z
  .array(
    z.object({
      id: z
        .string()
        .optional()
        .describe("`p_in_collections` filter, `id` of collection"),
      title: z
        .string()
        .optional()
        .describe("`p_in_collections` filter, `title` of collection"),
      handle: z
        .string()
        .optional()
        .describe("`p_in_collections` filter, `handle` of the collection"),
    }),
  )
  .describe("Filter for product in collections");
export const filterValuePNotInCollectionsSchema =
  filterValuePInCollectionsSchema.describe(
    "Filter for product not in collections",
  );
export const filterValuePInProductsSchema = z
  .array(
    z.object({
      id: z
        .string()
        .optional()
        .describe("`p_in_products` filter, `id` of `product`"),
      title: z
        .string()
        .optional()
        .describe("`p_in_products` filter, `title` of `product`"),
      handle: z
        .string()
        .optional()
        .describe("`p_in_products` filter, `handle` of the `product`"),
    }),
  )
  .describe("Filter for product discount, product in handles");
export const filterValuePNotInProductsSchema =
  filterValuePInProductsSchema.describe(
    "Filter for product discount, product not in handles",
  );
export const filterValuePInTagsSchema = z
  .array(z.string())
  .describe("Filter for product discount, product has tags");
export const filterValuePNotInTagsSchema = z
  .array(z.string())
  .describe("Filter for product discount, NOT has tags");
export const filterValuePAllSchema = z
  .object({})
  .describe("Filter for product discount,\nthat chooses all products");
export const filterValuePInPriceRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`p_in_price_range` filter From price"),
    to: z.number().describe("`p_in_price_range` filter To price"),
  })
  .describe("Filter for product discount, product in price range");
export const filterValueOSubtotalInRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`o_subtotal_in_range` filter From price"),
    to: z.number().optional().describe("`o_subtotal_in_range` filter To price"),
  })
  .describe("Filter for order discount, subtotal in range");
export const filterValueOItemsCountInRangeSchema = z
  .object({
    from: z
      .number()
      .optional()
      .describe("`o_items_count_in_range` filter From count"),
    to: z
      .number()
      .optional()
      .describe("`o_items_count_in_range` filter To count"),
  })
  .describe("Filter for order discount, items count in range");
export const filterValueODateInRangeSchema = z
  .object({
    from: z
      .string()
      .optional()
      .describe("`o_date_in_range` filter From date `ISO` format"),
    to: z
      .string()
      .optional()
      .describe("`o_date_in_range` filter To date `ISO` format"),
  })
  .describe("Filter for order discount, subtotal in range");
export const filterValueOHasCustomersSchema = z
  .array(
    z.object({
      id: z.string().describe("`id` of `customer`"),
      email: z.string().optional().describe("(optional) `email` of `customer`"),
      firstname: z
        .string()
        .optional()
        .describe("(optional) readable `name` of `customer`"),
      lastname: z
        .string()
        .optional()
        .describe("(optional) readable `name` of `customer`"),
    }),
  )
  .describe("Filter for order discount, order has customer id");
export const filterMetaEnumSchema = z.object({
  any: z.object({
    id: z.number(),
    type: z.string(),
    op: z.string(),
    name: z.string().optional(),
  }),
  p_in_collections: z.object({
    id: z.literal(0),
    type: z.literal("product"),
    op: z.literal("p-in-collections"),
    name: z.string().optional(),
  }),
  p_not_in_collections: z.object({
    id: z.literal(1),
    type: z.literal("product"),
    op: z.literal("p-not-in-collections"),
    name: z.string().optional(),
  }),
  p_in_products: z.object({
    id: z.literal(2),
    type: z.literal("product"),
    op: z.literal("p-in-products"),
    name: z.string().optional(),
  }),
  p_not_in_products: z.object({
    id: z.literal(3),
    type: z.literal("product"),
    op: z.literal("p-not-in-products"),
    name: z.string().optional(),
  }),
  p_in_tags: z.object({
    id: z.literal(4),
    type: z.literal("product"),
    op: z.literal("p-in-tags"),
    name: z.string().optional(),
  }),
  p_not_in_tags: z.object({
    id: z.literal(5),
    type: z.literal("product"),
    op: z.literal("p-not-in-tags"),
    name: z.string().optional(),
  }),
  p_all: z.object({
    id: z.literal(6),
    type: z.literal("product"),
    op: z.literal("p-all"),
    name: z.string().optional(),
  }),
  p_in_price_range: z.object({
    id: z.literal(7),
    type: z.literal("product"),
    op: z.literal("p-in-price-range"),
    name: z.string().optional(),
  }),
  o_subtotal_in_range: z.object({
    id: z.literal(100),
    type: z.literal("order"),
    op: z.literal("o-subtotal-in-range"),
    name: z.string().optional(),
  }),
  o_items_count_in_range: z.object({
    id: z.literal(101),
    type: z.literal("order"),
    op: z.literal("o-items-count-in-range"),
    name: z.string().optional(),
  }),
  o_date_in_range: z.object({
    id: z.literal(102),
    type: z.literal("order"),
    op: z.literal("o-date-in-range"),
    name: z.string().optional(),
  }),
  o_has_customer: z.object({
    id: z.literal(103),
    type: z.literal("order"),
    op: z.literal("o-has-customer"),
    name: z.string().optional(),
  }),
});
export const regularDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`RegularDiscountExtra` params, Fixed price addition"),
    percent: z.number().describe("`RegularDiscountExtra` params, Percents off"),
  })
  .describe("Parameters of a regular discount");
export const orderDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`OrderDiscountExtra` params, Fixed price addition"),
    percent: z.number().describe("`OrderDiscountExtra` params, Percents off"),
    free_shipping: z
      .boolean()
      .optional()
      .describe("`OrderDiscountExtra` params, Do we have free shipping ?"),
  })
  .describe("Parameters of order discount");
export const bulkDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`BulkDiscountExtra` params, Fixed price addition"),
    percent: z.number().describe("`BulkDiscountExtra` params, Percents off"),
    qty: z
      .number()
      .describe(
        "`BulkDiscountExtra` params, The integer quantity\nfor which the discount is given",
      ),
    recursive: z
      .boolean()
      .optional()
      .describe(
        "`BulkDiscountExtra` params, Apply the discount as\nmany times as possible",
      ),
  })
  .describe("Parameters of bulk discount");
export const bundleDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`BundleDiscountExtra` params, Fixed price addition"),
    percent: z.number().describe("`BundleDiscountExtra` params, Percents off"),
    recursive: z
      .boolean()
      .optional()
      .describe(
        "`BundleDiscountExtra` params, Apply the discount\nas many times as possible",
      ),
  })
  .describe("Parameters of bulk discount");
export const discountMetaEnumSchema = z
  .object({
    regular: z.object({
      id: z.literal(0),
      type: z.literal("regular"),
      name: z.string().optional(),
    }),
    bulk: z.object({
      id: z.literal(1),
      type: z.literal("bulk"),
      name: z.string().optional(),
    }),
    buy_x_get_y: z.object({
      id: z.literal(2),
      type: z.literal("buy_x_get_y"),
      name: z.string().optional(),
    }),
    order: z.object({
      id: z.literal(3),
      type: z.literal("order"),
      name: z.string().optional(),
    }),
    bundle: z.object({
      id: z.literal(4),
      type: z.literal("bundle"),
      name: z.string().optional(),
    }),
    any: z.object({
      id: z.number(),
      type: z.string(),
      name: z.string().optional(),
    }),
  })
  .describe(
    "Discount meta data,\nsee <a href='#DiscountMetaEnum'>#DiscountMetaEnum</a>",
  );
export const addressTypeSchema = z
  .object({
    firstname: z.string().optional().describe("First name of recipient"),
    lastname: z.string().optional().describe("Last name of recipient"),
    phone_number: z
      .string()
      .regex(/^([+]?d{1,2}[-s]?|)d{3}[-s]?d{3}[-s]?d{4}$ Invalid phone number/)
      .optional()
      .describe("The phone number of the recipient"),
    company: z
      .string()
      .optional()
      .describe("Optional company name of recipient"),
    street1: z.string().optional().describe("Street address 1"),
    street2: z.string().optional().describe("Street address 2"),
    city: z.string().optional().describe("City"),
    country: z.string().optional().describe("Country"),
    state: z.string().optional().describe("State"),
    zip_code: z.string().optional().describe("ZIP code"),
    postal_code: z.string().optional().describe("Postal code"),
  })
  .describe("Address type");
export const notificationActionTypeSchema = z
  .union([z.literal("route"), z.literal("url")])
  .describe(
    "'route' means routing inside admin panel 'url' is linking to a url",
  );
export const notificationActionRouteParamsSchema = z
  .object({
    collection: z.string().describe("Which collection"),
    document: z.string().describe("Which document"),
  })
  .describe("route inside admin panel action params");
export const notificationActionUrlParamsSchema = z
  .object({
    new_window: z.boolean().optional().describe("Ppen the url in new window"),
    url: z.string().describe("The url to open"),
  })
  .describe("Action params for actions of type 'url'");
export const orderContactSchema = z
  .object({
    firstname: z.string().optional().describe("First name"),
    lastname: z.string().optional().describe("Last name"),
    phone_number: z.string().optional().describe("Phone number"),
    email: z.string().optional().describe("Email"),
    customer_id: z.string().optional().describe("Customer `id`"),
  })
  .describe("Order buyer info");
export const validationEntrySchema = z
  .object({
    id: z.string().describe("`id`"),
    title: z
      .string()
      .min(3, "Title should be longer than 3")
      .optional()
      .describe("title"),
    message: z
      .union([
        z.literal("shipping-method-not-found"),
        z.literal("product-not-exists"),
        z.literal("product-out-of-stock"),
        z.literal("product-not-enough-stock"),
        z.literal("product-inactive"),
      ])
      .optional()
      .describe("message"),
  })
  .describe(
    "Checkouts or draft orders might be validated\nin automatic systems",
  );
export const fulfillOptionsEnumSchema = z
  .object({
    draft: z.object({
      id: z.literal(0),
      name2: z.literal("draft"),
      name: z.string().optional(),
    }),
    processing: z.object({
      id: z.literal(1),
      name2: z.literal("processing"),
      name: z.string().optional(),
    }),
    shipped: z.object({
      id: z.literal(2),
      name2: z.literal("shipped"),
      name: z.string().optional(),
    }),
    fulfilled: z.object({
      id: z.literal(3),
      name2: z.literal("fulfilled"),
      name: z.string().optional(),
    }),
    cancelled: z.object({
      id: z.literal(4),
      name2: z.literal("cancelled"),
      name: z.string().optional(),
    }),
  })
  .describe(
    "Fulfillment options encapsulate the current state,\nsee <a href='#FulfillOptionsEnum'>#FulfillOptionsEnum</a>",
  );
export const paymentOptionsEnumSchema = z
  .object({
    unpaid: z.object({
      id: z.literal(0),
      name: z.string().optional(),
      name2: z.literal("unpaid"),
    }),
    authorized: z.object({
      id: z.literal(1),
      name: z.string().optional(),
      name2: z.literal("authorized"),
    }),
    captured: z.object({
      id: z.literal(2),
      name: z.string().optional(),
      name2: z.literal("captured"),
    }),
    requires_auth: z.object({
      id: z.literal(3),
      name: z.string().optional(),
      name2: z.literal("requires_auth"),
    }),
    voided: z.object({
      id: z.literal(4),
      name: z.string().optional(),
      name2: z.literal("voided"),
    }),
    failed: z.object({
      id: z.literal(5),
      name: z.string().optional(),
      name2: z.literal("failed"),
    }),
    partially_paid: z.object({
      id: z.literal(6),
      name: z.string().optional(),
      name2: z.literal("partially_paid"),
    }),
    refunded: z.object({
      id: z.literal(7),
      name: z.string().optional(),
      name2: z.literal("refunded"),
    }),
    partially_refunded: z.object({
      id: z.literal(8),
      name: z.string().optional(),
      name2: z.literal("partially_refunded"),
    }),
  })
  .describe(
    "Payment options encapsulate the current state,\nsee <a href='#PaymentOptionsEnum'>#PaymentOptionsEnum</a>",
  );
export const checkoutStatusEnumSchema = z
  .object({
    created: z.object({
      id: z.literal(0),
      name2: z.literal("created"),
      name: z.string().optional(),
    }),
    requires_action: z.object({
      id: z.literal(1),
      name2: z.literal("requires_action"),
      name: z.string().optional(),
    }),
    failed: z.object({
      id: z.literal(2),
      name2: z.literal("failed"),
      name: z.string().optional(),
    }),
    complete: z.object({
      id: z.literal(3),
      name2: z.literal("complete"),
      name: z.string().optional(),
    }),
    unknown: z.object({
      id: z.literal(4),
      name2: z.literal("unknown"),
      name: z.string().optional(),
    }),
  })
  .describe(
    "Checkout status encapsulate the current state,\nsee <a href='#CheckoutStatusEnum'>#CheckoutStatusEnum</a>",
  );
export const discountErrorSchema = z
  .object({
    discount_code: z.string().describe("`handle` of the discount"),
    message: z.string().describe("Error message"),
  })
  .describe("Discount error type");
export const ordersStatisticsEntitySchema = z
  .record(z.any())
  .and(
    z.object({
      handle: z.string().optional().describe("`handle` of entity"),
      id: z.string().optional().describe("`id` of entity"),
      title: z.string().optional().describe("`title` of entity"),
      count: z
        .number()
        .optional()
        .describe("`count` of entity occurences in the day"),
    }),
  )
  .describe("Stats of an `entity` in a day");
export const ordersStatisticsDayMetricSchema = z.object({
  total_income: z
    .number()
    .optional()
    .describe("The total income in a day for a metric"),
  count: z
    .number()
    .optional()
    .describe("The `count` of orders in a day for a metric"),
});
export const ordersStatisticsDaySchema = z
  .object({
    metrics: z
      .object({
        payments_captured: ordersStatisticsDayMetricSchema.optional(),
        payments_failed: ordersStatisticsDayMetricSchema.optional(),
        payments_unpaid: ordersStatisticsDayMetricSchema.optional(),
        checkouts_created: ordersStatisticsDayMetricSchema.optional(),
        checkouts_completed: ordersStatisticsDayMetricSchema.optional(),
        fulfillment_draft: ordersStatisticsDayMetricSchema.optional(),
        fulfillment_shipped: ordersStatisticsDayMetricSchema.optional(),
        fulfillment_processing: ordersStatisticsDayMetricSchema.optional(),
        fulfillment_cancelled: ordersStatisticsDayMetricSchema.optional(),
      })
      .describe("metrics for many `order` statuses"),
    day: z
      .union([z.string(), z.number()])
      .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
    products: z
      .record(
        z
          .union([handleSchema, idSchema])
          .describe("The `products` found in all created orders"),
        ordersStatisticsEntitySchema.describe(
          "The `products` found in all created orders",
        ),
      )
      .optional()
      .describe("The `products` found in all created orders"),
    collections: z
      .record(
        z
          .union([handleSchema, idSchema])
          .describe("The `collections` found in all created orders"),
        ordersStatisticsEntitySchema.describe(
          "The `collections` found in all created orders",
        ),
      )
      .optional()
      .describe("The `collections` found in all created orders"),
    discounts: z
      .record(
        z
          .union([handleSchema, idSchema])
          .describe("The `discounts` found in all created orders"),
        ordersStatisticsEntitySchema.describe(
          "The `discounts` found in all created orders",
        ),
      )
      .optional()
      .describe("The `discounts` found in all created orders"),
    tags: z
      .record(
        z
          .union([handleSchema, idSchema])
          .describe("The `tags` found in all created orders `products`"),
        ordersStatisticsEntitySchema.describe(
          "The `tags` found in all created orders `products`",
        ),
      )
      .optional()
      .describe("The `tags` found in all created orders `products`"),
  })
  .describe("Stats of a day");
export const ordersStatisticsTypeSchema = z
  .object({
    days: z
      .record(
        z.union([z.number(), z.string()]).describe("The days statistics"),
        ordersStatisticsDaySchema.describe("The days statistics"),
      )
      .optional()
      .describe("The days statistics"),
    from_day: z
      .union([z.string(), z.number()])
      .optional()
      .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
    to_day: z
      .union([z.string(), z.number()])
      .optional()
      .describe("The date in string `ISO` / `UTC` / `timestamp` format"),
    count_days: z
      .number()
      .optional()
      .describe("The count of days in `from_day` to `to_day`"),
  })
  .describe("`Statisitics` of requested days");
export const configFieldSchema = z.object({
  key: z.string().describe("the `key` of the field"),
  value: z.any().optional().describe("the `value` of the field"),
  description: z.string().optional().describe("the `description` of the field"),
  name: z.string().describe("the `name` of the field"),
  editable: z.boolean().optional().describe("Is the field editable ?"),
  metadata: z
    .object({
      component: z.union([
        z.literal("select"),
        z.literal("input"),
        z.literal("label"),
        z.literal("textarea"),
      ]),
      params: z.any(),
    })
    .describe("The type of the `field`"),
});
export const extensionInfoSchema = z
  .object({
    name: z.string().describe("name of the `extension`"),
    description: z
      .string()
      .optional()
      .describe("description of the `extension`"),
    logo_url: z
      .string()
      .optional()
      .describe("logo url (or even data-url) of the `extension`"),
    url: z.string().optional().describe("url of the extension website"),
  })
  .describe("`extension` description, logos and urls");
export const extensionActionSchema = z
  .object({
    name: z.string().describe("action name for display"),
    handle: z.string().describe("action handle for invocation at backend"),
    description: z
      .string()
      .optional()
      .describe(
        "optional description of what will happen\nif the action is executed",
      ),
  })
  .describe(
    "Every `extension` have `actions`,  that are registered as\n**REST** endpoints",
  );
export const extensionItemGetSchema = z
  .object({
    info: extensionInfoSchema.describe(
      "The info such as `name`, `description` etc..",
    ),
    actions: z
      .array(extensionActionSchema)
      .describe("A list of `actions` supported by the `extension`"),
    config: z.any().describe("The extension's configuration"),
    handle: z.string().describe("The `handle` of the `extension`"),
  })
  .describe("Upon querying the `extension`");
export const paymentGatewayInfoSchema = extensionInfoSchema.describe(
  "Payment gateway description, logos and urls",
);
export const paymentGatewayActionSchema = extensionActionSchema
  .and(
    z.object({
      parameters: z
        .array(configFieldSchema)
        .optional()
        .describe(
          "Action might have extra parameters,\nfor example a partial refund action, may specify a variable value\nfor refunding, also with some of the `capture` actions,\nwhich may capture less than intended.",
        ),
    }),
  )
  .describe(
    "Upon status query, the gateway return a list of possible actions,\nsuch as `void`, `capture`, `refund` etc...",
  );
export const paymentGatewayItemGetSchema = z
  .object({
    info: paymentGatewayInfoSchema.describe(
      "The info such as `name`, `description` etc..",
    ),
    actions: z
      .array(paymentGatewayActionSchema)
      .describe("A list of `actions` supported by the gateway"),
    config: z.any().describe("The gateway's configuration"),
    handle: z.string().describe("The `handle` of the `gateway`"),
  })
  .describe("Upon querying the payment gateways");
export const quickSearchResourceSchema = z
  .object({
    id: z.string(),
    handle: z.string().optional(),
    title: z.string().optional(),
  })
  .describe("result of quick search for a specific `resource`");
export const tablesSchema = z.any().describe("full result of quick search");
export const quickSearchResultSchema = z.record(
  tablesSchema,
  z.array(quickSearchResourceSchema),
);
export const baseTypeSchema = idableConcreteSchema
  .extend(timestampsSchema.shape)
  .extend({
    media: z.array(z.string()).optional().describe("List of images urls"),
    attributes: z
      .array(attributeTypeSchema)
      .optional()
      .describe("List of attributes"),
    tags: z
      .array(z.string())
      .optional()
      .describe("List of tags , example ['genere_action', 'rated_M', ...]"),
    description: z.string().optional().describe("Rich description"),
    active: z.boolean().optional().describe("Is the entity active ?"),
  });
export const authUserTypeSchema = baseTypeSchema
  .omit({ id: true })
  .and(authBaseTypeSchema)
  .and(
    z.object({
      id: z.string().describe("ID"),
      confirmed_mail: z
        .boolean()
        .optional()
        .describe("Is the email confirmed ?"),
      roles: z
        .array(roleSchema)
        .optional()
        .describe("list of roles and authorizations of the user"),
      tags: z.array(z.string()).optional().describe("tags"),
    }),
  )
  .describe("Auth user type");
export const collectionTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("The `handle` of the entity"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of collection"),
  active: z.boolean().describe("Is the entity active ?"),
  published: z
    .string()
    .optional()
    .describe(
      "Collections can be exported into\njson with products, this is the url",
    ),
});
export const collectionTypeUpsertSchema = collectionTypeSchema
  .omit({ id: true, handle: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Collection upsert type");
export const variantOptionSchema = z
  .object({
    name: z
      .string()
      .min(3, "Name should be longer than 3")
      .describe("Variant option name (for example 'Size')"),
    id: z.string().describe("Variant option id"),
    values: z
      .array(textEntitySchema)
      .describe(
        "Variant option values\n(for example `Small` / `Medium` / `Large` ..)",
      ),
  })
  .describe("The data of a variant option");
export const filterSchema = z
  .object({
    meta: z
      .union([
        filterMetaEnumSchema.shape.p_all,
        filterMetaEnumSchema.shape.p_in_collections,
        filterMetaEnumSchema.shape.p_not_in_collections,
        filterMetaEnumSchema.shape.p_in_tags,
        filterMetaEnumSchema.shape.p_not_in_tags,
        filterMetaEnumSchema.shape.p_in_products,
        filterMetaEnumSchema.shape.p_not_in_products,
        filterMetaEnumSchema.shape.p_in_price_range,
        filterMetaEnumSchema.shape.o_date_in_range,
        filterMetaEnumSchema.shape.o_has_customer,
        filterMetaEnumSchema.shape.o_items_count_in_range,
        filterMetaEnumSchema.shape.o_subtotal_in_range,
        filterMetaEnumSchema.shape.any,
      ])
      .describe("Meta data related to identifying the filter"),
    value: z
      .union([
        filterValuePInCollectionsSchema,
        filterValuePNotInCollectionsSchema,
        filterValuePInProductsSchema,
        filterValuePNotInProductsSchema,
        filterValuePInTagsSchema,
        filterValuePNotInTagsSchema,
        filterValuePInPriceRangeSchema,
        filterValueOSubtotalInRangeSchema,
        filterValueOItemsCountInRangeSchema,
        filterValueODateInRangeSchema,
        filterValueOHasCustomersSchema,
      ])
      .optional()
      .describe("The filter params"),
  })
  .describe("Discount filter schema");
export const buyXGetYDiscountExtraSchema = z
  .object({
    fixed: z
      .number()
      .describe("`BuyXGetYDiscountExtra` params, Fixed price addition"),
    percent: z
      .number()
      .describe("`BuyXGetYDiscountExtra` params, Percents off"),
    qty_x: z
      .number()
      .describe(
        "`BuyXGetYDiscountExtra` params, The integer\nquantity of BUY X",
      ),
    qty_y: z
      .number()
      .describe(
        "`BuyXGetYDiscountExtra` params, The integer quantity\nof BUY Y",
      ),
    filters_y: z
      .array(filterSchema)
      .describe(
        "`BuyXGetYDiscountExtra` params, The filters for what\na customer gets (Y)",
      ),
    recursive: z
      .boolean()
      .optional()
      .describe(
        "`BuyXGetYDiscountExtra` params, Apply the discount\nas many times as possible",
      ),
  })
  .describe("Parameters of bulk discount");
export const shippingMethodTypeSchema = baseTypeSchema.extend({
  price: z
    .number()
    .min(0, "Please set a price >= 0")
    .describe("Shipping method price"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Name of shipping method"),
  handle: z.string().describe("Readable `handle` of shipping"),
});
export const postTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("Unique `handle`"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of post"),
  text: z.string().describe("Rich text of post"),
});
export const customerTypeSchema = baseTypeSchema.extend({
  auth_id: z
    .string()
    .optional()
    .describe(
      "The `auth id` of the customer. it is the same as\ncustomer `id` with `au` prefix instead",
    ),
  firstname: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("Firstname"),
  lastname: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("Lastname"),
  email: z.string().email().describe("Email of customer"),
  phone_number: z
    .string()
    .regex(/^([+]?d{1,2}[-s]?|)d{3}[-s]?d{3}[-s]?d{4}$/)
    .optional()
    .describe("The phone number"),
  address: addressTypeSchema.optional().describe("Address info of customer"),
});
export const customerTypeUpsertSchema = customerTypeSchema
  .omit({ id: true, handle: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Customer upsert type");
export const imageTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("Unique handle"),
  name: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("Name"),
  url: z
    .string()
    .min(1, "Should be longer than 1 characters")
    .describe("It's published public url"),
  usage: z
    .array(z.string())
    .optional()
    .describe("List of assets using this image"),
});
export const imageTypeUpsertSchema = imageTypeSchema
  .omit({ id: true, handle: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Image upsert type");
export const shippingMethodTypeUpsertSchema = shippingMethodTypeSchema
  .omit({ id: true, handle: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Shipping upsert type");
export const postTypeUpsertSchema = postTypeSchema
  .omit({ id: true, handle: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Post upsert type");
export const settingsTypeSchema = baseTypeSchema;
export const notificationActionSchema = z
  .object({
    name: z.string().optional().describe("Name of the action"),
    type: notificationActionTypeSchema
      .optional()
      .describe("The type of action"),
    params: z
      .union([
        notificationActionRouteParamsSchema,
        notificationActionUrlParamsSchema,
      ])
      .optional()
      .describe("Extra params for the actions type"),
  })
  .describe(
    "Each notification may have an actionable item\nassociated with it. For example, clicking an order notification\nwill route to the order page",
  );
export const orderStatusSchema = z
  .object({
    checkout: z
      .union([
        checkoutStatusEnumSchema.shape.complete,
        checkoutStatusEnumSchema.shape.created,
        checkoutStatusEnumSchema.shape.failed,
        checkoutStatusEnumSchema.shape.requires_action,
        checkoutStatusEnumSchema.shape.unknown,
        z.object({
          id: z.number(),
          name2: z.string(),
        }),
      ])
      .describe("`checkout` status"),
    payment: z
      .union([
        paymentOptionsEnumSchema.shape.authorized,
        paymentOptionsEnumSchema.shape.captured,
        paymentOptionsEnumSchema.shape.failed,
        paymentOptionsEnumSchema.shape.partially_paid,
        paymentOptionsEnumSchema.shape.partially_refunded,
        paymentOptionsEnumSchema.shape.refunded,
        paymentOptionsEnumSchema.shape.requires_auth,
        paymentOptionsEnumSchema.shape.unpaid,
        paymentOptionsEnumSchema.shape.voided,
        z.object({
          id: z.number(),
          name2: z.string(),
        }),
      ])
      .describe("`payment` status"),
    fulfillment: z
      .union([
        fulfillOptionsEnumSchema.shape.cancelled,
        fulfillOptionsEnumSchema.shape.draft,
        fulfillOptionsEnumSchema.shape.fulfilled,
        fulfillOptionsEnumSchema.shape.processing,
        fulfillOptionsEnumSchema.shape.shipped,
        z.object({
          id: z.number(),
          name2: z.string(),
        }),
      ])
      .describe("`fulfillment` status"),
  })
  .describe("Status of `checkout`, `fulfillment` and `payment`");
export const paymentGatewayStatusSchema = z
  .object({
    actions: z
      .array(paymentGatewayActionSchema)
      .optional()
      .describe("List of possible actions to take"),
    messages: z
      .array(z.string())
      .optional()
      .describe(
        "A list of messages of the current payment status,\nfor example `150$ were authorized...`",
      ),
  })
  .describe("A payment `status`");
export const templateTypeSchema = baseTypeSchema.extend({
  handle: z.string().optional().describe("`handle`"),
  title: z.string().describe("`title` of `template`"),
  template_html: z
    .string()
    .optional()
    .describe("The **HTML** `template` `handlebars` string"),
  template_text: z
    .string()
    .optional()
    .describe("The **TEXT** `template` `handlebars` string"),
  reference_example_input: z
    .any()
    .optional()
    .describe("A reference example input for the template"),
});
export const templateTypeUpsertSchema = templateTypeSchema
  .omit({ id: true, handle: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Upsert type for email template");
export const discountDetailsSchema = z
  .object({
    meta: z
      .union([
        discountMetaEnumSchema.shape.regular,
        discountMetaEnumSchema.shape.bulk,
        discountMetaEnumSchema.shape.bundle,
        discountMetaEnumSchema.shape.buy_x_get_y,
        discountMetaEnumSchema.shape.order,
        discountMetaEnumSchema.shape.any,
      ])
      .describe("metadata to identify the type of discount"),
    extra: z
      .union([
        regularDiscountExtraSchema,
        orderDiscountExtraSchema,
        bulkDiscountExtraSchema,
        buyXGetYDiscountExtraSchema,
        bundleDiscountExtraSchema,
      ])
      .describe("Extra parameters of the specific discount type"),
  })
  .describe(
    "The details of how to apply a discount.\nThe type of discount and it's params",
  );
const baseNotificationTypeSchema = z.object({
  message: z
    .string()
    .describe(
      "Message of notification, can be markdown,\nmarkup or plain text",
    ),
  author: z.string().optional().describe("Author of the notification"),
  actions: z
    .array(notificationActionSchema)
    .optional()
    .describe("List of actions"),
  search: z.array(z.string()).optional().describe("search terms"),
  id: z.string().optional().describe("`id` of notification"),
});
export const notificationTypeSchema = baseNotificationTypeSchema.extend(
  timestampsSchema.shape,
);
export const notificationTypeUpsertSchema = baseNotificationTypeSchema;
export const orderPaymentGatewayDataSchema = z
  .object({
    gateway_handle: z.string().describe("The payment gateway identifier"),
    on_checkout_create: z
      .any()
      .optional()
      .describe(
        "Result of gateway at checkout creation, this will later be given\nto the `payment gateway` on any interaction, which will use it to identify the payment.",
      ),
    latest_status: paymentGatewayStatusSchema
      .optional()
      .describe("Latest status of payment for caching"),
  })
  .describe("How did the order interacted with a payment gateway ?");
export const discountInfoSchema = z
  .object({
    details: discountDetailsSchema.describe(
      "Discount details, decribes the `discount` type and more",
    ),
    filters: z
      .array(filterSchema)
      .min(1, "You should Specify at least 1 Filter")
      .describe("List of `discount` filters"),
  })
  .describe("details and filters of the discount");
export const discountTypeSchema = baseTypeSchema.extend({
  active: z.boolean().describe("Is the discount active ?"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of discount"),
  handle: z.string().describe("Discount `code` / `handle`"),
  priority: z
    .number()
    .describe("The order in which to apply the discounts\nstack (priority)"),
  published: z
    .string()
    .optional()
    .describe(
      "Discounts may generate collections, this\nis the collection handle that contains the applicable\ndiscount products",
    ),
  info: discountInfoSchema.describe("Details and filters of the discount"),
  application: z
    .union([
      discountApplicationEnumSchema.shape.Auto,
      discountApplicationEnumSchema.shape.Manual,
      z.object({
        id: z.number(),
        name: z.string().optional(),
        name2: z.string(),
      }),
    ])
    .describe("Discount application (`automatic` and `manual`)"),
});
export const discountTypeUpsertSchema = discountTypeSchema
  .omit({ id: true, handle: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Discount upsert type");
export const baseProductTypeSchema = baseTypeSchema.extend({
  handle: z.string().describe("The readable unique product `handle`"),
  isbn: z
    .string()
    .optional()
    .describe("The International Standard Book Number (`ISBN`)"),
  title: z
    .string()
    .min(3, "Title should be longer than 3")
    .describe("Title of the product"),
  active: z.boolean().describe("Is the product active ?"),
  video: z.string().optional().describe("Video media url"),
  price: z.number().min(0).describe("Price of the product"),
  qty: z.number().min(0).describe("Integer stock quantity of product"),
  compare_at_price: z
    .number()
    .min(0)
    .optional()
    .describe("Compare at price point"),
  collections: z
    .array(collectionTypeSchema)
    .optional()
    .describe("Collections this product belongs to, expanded field"),
  discounts: z
    .array(discountTypeSchema)
    .optional()
    .describe("Discounts we know were applied to this product,\nexpanded type"),
});
export const variantTypeSchema = baseProductTypeSchema.extend({
  parent_handle: z
    .string()
    .describe("Handle of parent product in case this\nproduct is a variant"),
  parent_id: z
    .string()
    .describe("`id` of parent product in case this\nproduct is a variant"),
  variant_hint: z
    .array(variantOptionSelectionSchema)
    .describe("Internal usage, clarifies the variant\nprojected options"),
  related_products: z
    .array(baseProductTypeSchema)
    .optional()
    .describe(
      "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
    ),
});
export const variantTypeUpsertSchema = variantTypeSchema
  .omit({
    collections: true,
    published: true,
    discounts: true,
    related_products: true,
    id: true,
    handle: true,
  })
  .and(
    z.object({
      collections: z
        .array(handleAndIDSchema)
        .optional()
        .describe(
          "List of collections to add the product into,\nthis is an explicit connection, to form a better UX experience",
        ),
      related_products: z
        .array(baseProductTypeSchema.pick({ id: true, handle: true }))
        .optional()
        .describe(
          "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
        ),
    }),
  )
  .and(withOptionalHandleOrIDSchema)
  .describe("Variant upsert type");
export const productTypeSchema = baseProductTypeSchema.extend({
  variants: z
    .array(variantTypeSchema)
    .optional()
    .describe("Product variants, expanded type"),
  variants_options: z
    .array(variantOptionSchema)
    .optional()
    .describe("Variants options info"),
  related_products: z
    .array(baseProductTypeSchema)
    .optional()
    .describe(
      "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
    ),
});
export const productTypeUpsertSchema = productTypeSchema
  .omit({
    collections: true,
    published: true,
    related_products: true,
    discounts: true,
    variants: true,
    id: true,
    handle: true,
  })
  .and(
    z.object({
      collections: z
        .array(handleAndIDSchema)
        .optional()
        .describe(
          "List of collections to add the product into,\nthis is an explicit connection, to form a better UX experience",
        ),
      related_products: z
        .array(handleAndIDSchema)
        .optional()
        .describe(
          "List of related products to add the product into,\nthis is an explicit connection, to form a better UX experience",
        ),
    }),
  )
  .and(withOptionalHandleOrIDSchema)
  .describe("Product upsert type");
export const storefrontTypeSchema = baseTypeSchema.extend({
  active: z.boolean().describe("Is the entity active ?"),
  handle: z.string().describe("Readable `handle`"),
  title: z.string().min(3, "Title should be longer than 3").describe("Title"),
  video: z.string().optional().describe("Video url"),
  published: z
    .string()
    .optional()
    .describe(
      "Storefronts may be exported to `json` for CDN,\nthis is the `url`",
    ),
  collections: z
    .array(collectionTypeSchema)
    .optional()
    .describe("Collections related to this storefront"),
  products: z
    .array(productTypeSchema)
    .optional()
    .describe("Products related to this storefront"),
  shipping_methods: z
    .array(shippingMethodTypeSchema)
    .optional()
    .describe("Shipping methods related to this storefront"),
  discounts: z
    .array(discountTypeSchema)
    .optional()
    .describe("Discounts related to this storefront"),
  posts: z
    .array(postTypeSchema)
    .optional()
    .describe("Posts related to this storefront"),
});
export const storefrontTypeUpsertSchema = storefrontTypeSchema
  .omit({
    collections: true,
    products: true,
    posts: true,
    discounts: true,
    shipping_methods: true,
    id: true,
    handle: true,
  })
  .and(
    z.object({
      collections: z
        .array(handleAndIDSchema)
        .optional()
        .describe("Collections related to this storefront"),
      products: z
        .array(handleAndIDSchema)
        .optional()
        .describe("Products related to this storefront"),
      shipping_methods: z
        .array(handleAndIDSchema)
        .optional()
        .describe("Shipping methods related to this storefront"),
      discounts: z
        .array(handleAndIDSchema)
        .optional()
        .describe("Discounts related to this storefront"),
      posts: z
        .array(handleAndIDSchema)
        .optional()
        .describe("Posts related to this storefront"),
    }),
  )
  .and(withOptionalHandleOrIDSchema)
  .describe("Storefront upsert type");
export const lineItemSchema = z
  .object({
    id: z.string().describe("`id` or `handle` of product"),
    price: z.number().optional().describe("Product price snapshot"),
    qty: z
      .number()
      .describe("Integer quantity of how many such products\nwere bought"),
    stock_reserved: z
      .number()
      .optional()
      .describe(
        "Used by order to indicate it has reserved stock\nand it's amount",
      ),
    data: productTypeSchema
      .optional()
      .describe("(optional) the product data snapshot for\nfuture integrity"),
  })
  .describe("A line item is a product, that appeared in an order");
export const evoEntrySchema = z
  .object({
    discount: discountTypeSchema.optional().describe("Discount at this step"),
    discount_code: z.string().optional().describe("The discount code `handle`"),
    total_discount: z
      .number()
      .optional()
      .describe("The amount of money that was discounted\nby this discount"),
    quantity_undiscounted: z
      .number()
      .optional()
      .describe("How many items are left to discount"),
    quantity_discounted: z
      .number()
      .optional()
      .describe("How many items were discounted now"),
    subtotal: z
      .number()
      .optional()
      .describe("Running subtotal without shipping"),
    total: z.number().optional().describe("Running total"),
    line_items_next: z
      .array(lineItemSchema)
      .optional()
      .describe("Available line items after discount"),
  })
  .describe(
    "Explains how a specific discount was used\nto discount line items",
  );
export const variantCombinationSchema = z
  .object({
    selection: z
      .array(variantOptionSelectionSchema)
      .describe("A list of selection of option and value"),
    product: productTypeSchema.describe(
      "The product data associated with this variant",
    ),
  })
  .describe("A tuple of option id and selected value id");
export const baseCheckoutCreateTypeSchema = z.object({
  contact: orderContactSchema.optional().describe("Buyer info"),
  address: addressTypeSchema.optional().describe("Shipping address info"),
  line_items: z
    .array(lineItemSchema)
    .describe("Line items is a list of the purchased products"),
  notes: z.string().optional().describe("Notes for the order"),
  shipping_method: shippingMethodTypeSchema
    .partial()
    .describe("Shipping method info"),
});
export const checkoutCreateTypeSchema = baseCheckoutCreateTypeSchema.extend({
  coupons: z
    .array(discountTypeSchema)
    .optional()
    .describe("A list of manual coupons handles"),
});
export const pricingDataSchema = z
  .object({
    evo: z
      .array(evoEntrySchema)
      .optional()
      .describe("Explanation of how discounts stack and change pricing"),
    shipping_method: shippingMethodTypeSchema
      .optional()
      .describe("Selected shipping method"),
    subtotal_undiscounted: z
      .number()
      .describe("Subtotal of items price before discounts"),
    subtotal_discount: z
      .number()
      .describe("Sum of all discounts at all stages"),
    subtotal: z
      .number()
      .describe("`subtotal_undiscounted` - `subtotal_discount`"),
    total: z.number().describe("`subtotal` + `shipping`"),
    quantity_total: z.number().describe("How many items are eligible"),
    quantity_discounted: z.number().describe("How many items were discounted"),
    uid: z.string().optional().describe("Authentication user id"),
    errors: z.array(discountErrorSchema).optional().describe("Errors"),
  })
  .describe(
    "Pricing object exaplins how the pricing of an order\nwas calculated given a stack of automatic discounts, coupons,\nline items and shipping method",
  );
export const orderDataSchema = checkoutCreateTypeSchema
  .extend(baseTypeSchema.shape)
  .extend({
    status: orderStatusSchema.describe(
      "Status of `checkout`, `fulfillment` and `payment`",
    ),
    pricing: pricingDataSchema.describe("Pricing information"),
    validation: z
      .array(validationEntrySchema)
      .optional()
      .describe("In case the order went through validation"),
    payment_gateway: orderPaymentGatewayDataSchema
      .optional()
      .describe("Payment gateway info and status"),
  });
export const orderDataUpsertSchema = orderDataSchema
  .omit({ id: true })
  .and(withOptionalHandleOrIDSchema)
  .describe("Order upsert type");
